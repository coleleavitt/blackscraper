<!-- HTML header for doxygen 1.9.3-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IDAPython: IDP_Hooks Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Y2G1VBHRDB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-Y2G1VBHRDB');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="idapython.svg"/></td>
  <td id="projectalign">
   <div id="projectname">IDAPython<span id="projectnumber">&#160;9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classida__idp_1_1_i_d_p___hooks.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="classida__idp_1_1_i_d_p___hooks-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">IDP_Hooks Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for IDP_Hooks:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classida__idp_1_1_i_d_p___hooks.png" usemap="#IDP_5FHooks_map" alt=""/>
  <map id="IDP_5FHooks_map" name="IDP_5FHooks_map">
<area href="classida__idp_1_1__notify__when__dispatcher__t_1_1___i_d_p___hooks.html" alt="_notify_when_dispatcher_t._IDP_Hooks" shape="rect" coords="0,112,236,136"/>
<area href="classida__idp_1_1processor__t.html" alt="processor_t" shape="rect" coords="246,112,482,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a226b4b6da90e3cb1943cdc1416170446" id="r_a226b4b6da90e3cb1943cdc1416170446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a226b4b6da90e3cb1943cdc1416170446">__init__</a> (self, int _flags=0, int _hkcb_flags=1)</td></tr>
<tr class="separator:a226b4b6da90e3cb1943cdc1416170446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fc95a1ce9ec3113384503d194c8802" id="r_a75fc95a1ce9ec3113384503d194c8802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75fc95a1ce9ec3113384503d194c8802">hook</a> (self)</td></tr>
<tr class="separator:a75fc95a1ce9ec3113384503d194c8802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b323a538408e166ac784fb69d4b2938" id="r_a0b323a538408e166ac784fb69d4b2938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b323a538408e166ac784fb69d4b2938">unhook</a> (self)</td></tr>
<tr class="separator:a0b323a538408e166ac784fb69d4b2938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47227cbc59e9c885bed003cbfa8ace5e" id="r_a47227cbc59e9c885bed003cbfa8ace5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47227cbc59e9c885bed003cbfa8ace5e">ev_init</a> (self, str idp_modname)</td></tr>
<tr class="separator:a47227cbc59e9c885bed003cbfa8ace5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319b1ed8394d61d93bd98153eae51c2b" id="r_a319b1ed8394d61d93bd98153eae51c2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319b1ed8394d61d93bd98153eae51c2b">ev_term</a> (self)</td></tr>
<tr class="separator:a319b1ed8394d61d93bd98153eae51c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6c1b470e80c866bf5c520132d8faf9" id="r_abd6c1b470e80c866bf5c520132d8faf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd6c1b470e80c866bf5c520132d8faf9">ev_newprc</a> (self, int pnum, bool keep_cfg)</td></tr>
<tr class="separator:abd6c1b470e80c866bf5c520132d8faf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6175fecda1abe143895fdebdc88312" id="r_a6c6175fecda1abe143895fdebdc88312"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6175fecda1abe143895fdebdc88312">ev_newasm</a> (self, int asmnum)</td></tr>
<tr class="separator:a6c6175fecda1abe143895fdebdc88312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0f51af8ee71de92a728cf39c911da0" id="r_a2e0f51af8ee71de92a728cf39c911da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e0f51af8ee71de92a728cf39c911da0">ev_newfile</a> (self, 'char *' fname)</td></tr>
<tr class="separator:a2e0f51af8ee71de92a728cf39c911da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad139f674fbaec805ccbd858976c7ba7d" id="r_ad139f674fbaec805ccbd858976c7ba7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad139f674fbaec805ccbd858976c7ba7d">ev_oldfile</a> (self, 'char *' fname)</td></tr>
<tr class="separator:ad139f674fbaec805ccbd858976c7ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8528da1088f39b716318af4ebfba05c3" id="r_a8528da1088f39b716318af4ebfba05c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8528da1088f39b716318af4ebfba05c3">ev_newbinary</a> (self, 'char *' filename, 'qoff64_t' fileoff, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> basepara, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> binoff, 'uint64' nbytes)</td></tr>
<tr class="separator:a8528da1088f39b716318af4ebfba05c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3368d055da959872d3a9e8fb6bde547b" id="r_a3368d055da959872d3a9e8fb6bde547b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3368d055da959872d3a9e8fb6bde547b">ev_endbinary</a> (self, bool ok)</td></tr>
<tr class="separator:a3368d055da959872d3a9e8fb6bde547b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e02f3df91bf3186b718577215424a1" id="r_a02e02f3df91bf3186b718577215424a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e02f3df91bf3186b718577215424a1">ev_set_idp_options</a> (self, str keyword, int value_type, 'void const *' value, bool idb_loaded)</td></tr>
<tr class="separator:a02e02f3df91bf3186b718577215424a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d2aac99e9868c2b4a41e8fb41e392" id="r_a611d2aac99e9868c2b4a41e8fb41e392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a611d2aac99e9868c2b4a41e8fb41e392">ev_set_proc_options</a> (self, str options, int confidence)</td></tr>
<tr class="separator:a611d2aac99e9868c2b4a41e8fb41e392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf449162425148644af2032812c67acf" id="r_abf449162425148644af2032812c67acf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf449162425148644af2032812c67acf">ev_ana_insn</a> (self, 'insn_t *' out)</td></tr>
<tr class="separator:abf449162425148644af2032812c67acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4023cbeedf97e05de8fa5af1e9e8698" id="r_ac4023cbeedf97e05de8fa5af1e9e8698"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4023cbeedf97e05de8fa5af1e9e8698">ev_emu_insn</a> (self, 'insn_t const *' insn)</td></tr>
<tr class="separator:ac4023cbeedf97e05de8fa5af1e9e8698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437e405d5d8a5ca7246da22e02a22a11" id="r_a437e405d5d8a5ca7246da22e02a22a11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437e405d5d8a5ca7246da22e02a22a11">ev_out_header</a> (self, 'outctx_t *' outctx)</td></tr>
<tr class="separator:a437e405d5d8a5ca7246da22e02a22a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337c1fa66b36b2bb828d0bab2dda2faf" id="r_a337c1fa66b36b2bb828d0bab2dda2faf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a337c1fa66b36b2bb828d0bab2dda2faf">ev_out_footer</a> (self, 'outctx_t *' outctx)</td></tr>
<tr class="separator:a337c1fa66b36b2bb828d0bab2dda2faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0a3708b48a890307e39e6adb4ef2ec" id="r_acc0a3708b48a890307e39e6adb4ef2ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc0a3708b48a890307e39e6adb4ef2ec">ev_out_segstart</a> (self, 'outctx_t *' outctx, 'segment_t *' seg)</td></tr>
<tr class="separator:acc0a3708b48a890307e39e6adb4ef2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d0369271682dc4d2ec0adafde8b0c2" id="r_a08d0369271682dc4d2ec0adafde8b0c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d0369271682dc4d2ec0adafde8b0c2">ev_out_segend</a> (self, 'outctx_t *' outctx, 'segment_t *' seg)</td></tr>
<tr class="separator:a08d0369271682dc4d2ec0adafde8b0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3d8235a680d8d37eabe96ae72a5c0e" id="r_a9e3d8235a680d8d37eabe96ae72a5c0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e3d8235a680d8d37eabe96ae72a5c0e">ev_out_assumes</a> (self, 'outctx_t *' outctx)</td></tr>
<tr class="separator:a9e3d8235a680d8d37eabe96ae72a5c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89c6e9d63dbb1e02e49ed10d838f42" id="r_a8e89c6e9d63dbb1e02e49ed10d838f42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e89c6e9d63dbb1e02e49ed10d838f42">ev_out_insn</a> (self, 'outctx_t *' outctx)</td></tr>
<tr class="separator:a8e89c6e9d63dbb1e02e49ed10d838f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c8279611dda562f25eaf1596718df4" id="r_a31c8279611dda562f25eaf1596718df4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31c8279611dda562f25eaf1596718df4">ev_out_mnem</a> (self, 'outctx_t *' outctx)</td></tr>
<tr class="separator:a31c8279611dda562f25eaf1596718df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3550e39c504f52bd2e8a8c92892b03ec" id="r_a3550e39c504f52bd2e8a8c92892b03ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3550e39c504f52bd2e8a8c92892b03ec">ev_out_operand</a> (self, 'outctx_t *' outctx, 'op_t const *' op)</td></tr>
<tr class="separator:a3550e39c504f52bd2e8a8c92892b03ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef6821c579c6023fa3b46a916b9dc5c" id="r_aaef6821c579c6023fa3b46a916b9dc5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaef6821c579c6023fa3b46a916b9dc5c">ev_out_data</a> (self, 'outctx_t *' outctx, bool analyze_only)</td></tr>
<tr class="separator:aaef6821c579c6023fa3b46a916b9dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13078da2cb11548de8c320fac31a50f8" id="r_a13078da2cb11548de8c320fac31a50f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13078da2cb11548de8c320fac31a50f8">ev_out_label</a> (self, 'outctx_t *' outctx, str colored_name)</td></tr>
<tr class="separator:a13078da2cb11548de8c320fac31a50f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ad1a0f7645b3db9a8521c85538977c" id="r_a64ad1a0f7645b3db9a8521c85538977c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ad1a0f7645b3db9a8521c85538977c">ev_out_special_item</a> (self, 'outctx_t *' outctx, 'uchar' segtype)</td></tr>
<tr class="separator:a64ad1a0f7645b3db9a8521c85538977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9209689a03ade8e0713052326cad279c" id="r_a9209689a03ade8e0713052326cad279c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9209689a03ade8e0713052326cad279c">ev_gen_regvar_def</a> (self, 'outctx_t *' outctx, 'regvar_t *' v)</td></tr>
<tr class="separator:a9209689a03ade8e0713052326cad279c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe29614c17b1214aed1b7fc2270bf48" id="r_a1fe29614c17b1214aed1b7fc2270bf48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fe29614c17b1214aed1b7fc2270bf48">ev_gen_src_file_lnnum</a> (self, 'outctx_t *' outctx, str file, 'size_t' lnnum)</td></tr>
<tr class="separator:a1fe29614c17b1214aed1b7fc2270bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd6732c1a7bfc47c836f0c140d188c8" id="r_abbd6732c1a7bfc47c836f0c140d188c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbd6732c1a7bfc47c836f0c140d188c8">ev_creating_segm</a> (self, 'segment_t *' seg)</td></tr>
<tr class="separator:abbd6732c1a7bfc47c836f0c140d188c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add862e5422ccfad4fb703c48893405a4" id="r_add862e5422ccfad4fb703c48893405a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add862e5422ccfad4fb703c48893405a4">ev_moving_segm</a> (self, 'segment_t *' seg, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> to, int flags)</td></tr>
<tr class="separator:add862e5422ccfad4fb703c48893405a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa343c6918b624e6d2bfda32d510351ad" id="r_aa343c6918b624e6d2bfda32d510351ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa343c6918b624e6d2bfda32d510351ad">ev_coagulate</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> start_ea)</td></tr>
<tr class="separator:aa343c6918b624e6d2bfda32d510351ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320daefd98dfac488bfbc6edfcdd0033" id="r_a320daefd98dfac488bfbc6edfcdd0033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a320daefd98dfac488bfbc6edfcdd0033">ev_undefine</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:a320daefd98dfac488bfbc6edfcdd0033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2286312b285d2c941f781ae91dca1d87" id="r_a2286312b285d2c941f781ae91dca1d87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2286312b285d2c941f781ae91dca1d87">ev_treat_hindering_item</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> hindering_item_ea, 'flags64_t' new_item_flags, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> new_item_ea, 'asize_t' new_item_length)</td></tr>
<tr class="separator:a2286312b285d2c941f781ae91dca1d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26541b58a3abe06aedfb41cdcb1de961" id="r_a26541b58a3abe06aedfb41cdcb1de961"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26541b58a3abe06aedfb41cdcb1de961">ev_rename</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, str new_name)</td></tr>
<tr class="separator:a26541b58a3abe06aedfb41cdcb1de961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb5f82cf45213012f7de69ac5f6b3a" id="r_af6cb5f82cf45213012f7de69ac5f6b3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cb5f82cf45213012f7de69ac5f6b3a">ev_is_far_jump</a> (self, int icode)</td></tr>
<tr class="separator:af6cb5f82cf45213012f7de69ac5f6b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677260b53a80ece52243a1874af4ca73" id="r_a677260b53a80ece52243a1874af4ca73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a677260b53a80ece52243a1874af4ca73">ev_is_sane_insn</a> (self, 'insn_t const *' insn, int no_crefs)</td></tr>
<tr class="separator:a677260b53a80ece52243a1874af4ca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadf5a2249b6f5ba7fc101103f7c9d83" id="r_aeadf5a2249b6f5ba7fc101103f7c9d83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeadf5a2249b6f5ba7fc101103f7c9d83">ev_is_cond_insn</a> (self, 'insn_t const *' insn)</td></tr>
<tr class="separator:aeadf5a2249b6f5ba7fc101103f7c9d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6385f931ec2bd391d1194eb87ebcb336" id="r_a6385f931ec2bd391d1194eb87ebcb336"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6385f931ec2bd391d1194eb87ebcb336">ev_is_call_insn</a> (self, 'insn_t const *' insn)</td></tr>
<tr class="separator:a6385f931ec2bd391d1194eb87ebcb336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6682c9c3fca400e02882f3d7cb8260" id="r_adb6682c9c3fca400e02882f3d7cb8260"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb6682c9c3fca400e02882f3d7cb8260">ev_is_ret_insn</a> (self, 'insn_t const *' insn, 'uchar' flags)</td></tr>
<tr class="separator:adb6682c9c3fca400e02882f3d7cb8260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4665d83a54b5743a7e11a4f2eee8af" id="r_a3d4665d83a54b5743a7e11a4f2eee8af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d4665d83a54b5743a7e11a4f2eee8af">ev_may_be_func</a> (self, 'insn_t const *' insn, int state)</td></tr>
<tr class="separator:a3d4665d83a54b5743a7e11a4f2eee8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38e95e856805057446222cc1a0af07c" id="r_ab38e95e856805057446222cc1a0af07c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38e95e856805057446222cc1a0af07c">ev_is_basic_block_end</a> (self, 'insn_t const *' insn, bool call_insn_stops_block)</td></tr>
<tr class="separator:ab38e95e856805057446222cc1a0af07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae501f3f7ad278589c6219b3106f28e2f" id="r_ae501f3f7ad278589c6219b3106f28e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae501f3f7ad278589c6219b3106f28e2f">ev_is_indirect_jump</a> (self, 'insn_t const *' insn)</td></tr>
<tr class="separator:ae501f3f7ad278589c6219b3106f28e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d147a1a3a942c1688c4de42509173d7" id="r_a1d147a1a3a942c1688c4de42509173d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d147a1a3a942c1688c4de42509173d7">ev_is_insn_table_jump</a> (self)</td></tr>
<tr class="separator:a1d147a1a3a942c1688c4de42509173d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33067a0e77f5c0304c444199852826b9" id="r_a33067a0e77f5c0304c444199852826b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33067a0e77f5c0304c444199852826b9">ev_is_switch</a> (self, 'switch_info_t' si, 'insn_t const *' insn)</td></tr>
<tr class="separator:a33067a0e77f5c0304c444199852826b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09c3f1b589292c72a69bb7292d3ea7a" id="r_ad09c3f1b589292c72a69bb7292d3ea7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad09c3f1b589292c72a69bb7292d3ea7a">ev_calc_switch_cases</a> (self, 'casevec_t *' casevec, 'eavec_t *' targets, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> insn_ea, 'switch_info_t' si)</td></tr>
<tr class="separator:ad09c3f1b589292c72a69bb7292d3ea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6eddda5ae830e4c797be38feaed952" id="r_a2e6eddda5ae830e4c797be38feaed952"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e6eddda5ae830e4c797be38feaed952">ev_create_switch_xrefs</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> jumpea, 'switch_info_t' si)</td></tr>
<tr class="separator:a2e6eddda5ae830e4c797be38feaed952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de828bd6e18cc30b54ee5feb2f4a8f5" id="r_a7de828bd6e18cc30b54ee5feb2f4a8f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7de828bd6e18cc30b54ee5feb2f4a8f5">ev_is_align_insn</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:a7de828bd6e18cc30b54ee5feb2f4a8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac519cea11061dc53efd1c59d0de960f9" id="r_ac519cea11061dc53efd1c59d0de960f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac519cea11061dc53efd1c59d0de960f9">ev_is_alloca_probe</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:ac519cea11061dc53efd1c59d0de960f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b59495a2126cae40842c94e209ed75" id="r_a82b59495a2126cae40842c94e209ed75"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82b59495a2126cae40842c94e209ed75">ev_delay_slot_insn</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, bool bexec, bool fexec)</td></tr>
<tr class="separator:a82b59495a2126cae40842c94e209ed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7b42e359913087e27fa23a847c4c7a" id="r_a4b7b42e359913087e27fa23a847c4c7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b7b42e359913087e27fa23a847c4c7a">ev_is_sp_based</a> (self, 'int *' mode, 'insn_t const *' insn, 'op_t const *' op)</td></tr>
<tr class="separator:a4b7b42e359913087e27fa23a847c4c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171fe442670e90f9ba8ada8cc8c9fee3" id="r_a171fe442670e90f9ba8ada8cc8c9fee3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a171fe442670e90f9ba8ada8cc8c9fee3">ev_can_have_type</a> (self, 'op_t const *' op)</td></tr>
<tr class="separator:a171fe442670e90f9ba8ada8cc8c9fee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d56f8f59be2491dc5e9361f44e368b7" id="r_a2d56f8f59be2491dc5e9361f44e368b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d56f8f59be2491dc5e9361f44e368b7">ev_cmp_operands</a> (self, 'op_t const *' op1, 'op_t const *' op2)</td></tr>
<tr class="separator:a2d56f8f59be2491dc5e9361f44e368b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605fb2709cf5611cb4198335d5349b8e" id="r_a605fb2709cf5611cb4198335d5349b8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605fb2709cf5611cb4198335d5349b8e">ev_adjust_refinfo</a> (self, 'refinfo_t' ri, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, int n, 'fixup_data_t const *' fd)</td></tr>
<tr class="separator:a605fb2709cf5611cb4198335d5349b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64f54a2a890f8612d5860c6de7e4b01" id="r_ae64f54a2a890f8612d5860c6de7e4b01"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae64f54a2a890f8612d5860c6de7e4b01">ev_get_operand_string</a> (self, 'insn_t const *' insn, int opnum)</td></tr>
<tr class="separator:ae64f54a2a890f8612d5860c6de7e4b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e62f1f2ae524284ebecb8677810600" id="r_a78e62f1f2ae524284ebecb8677810600"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78e62f1f2ae524284ebecb8677810600">ev_get_reg_name</a> (self, int reg, 'size_t' width, int reghi)</td></tr>
<tr class="separator:a78e62f1f2ae524284ebecb8677810600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a42c721b8941dcaa2da92cdf7711fc6" id="r_a9a42c721b8941dcaa2da92cdf7711fc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a42c721b8941dcaa2da92cdf7711fc6">ev_str2reg</a> (self, str regname)</td></tr>
<tr class="separator:a9a42c721b8941dcaa2da92cdf7711fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14872926d65eafe7a620a509c32f6115" id="r_a14872926d65eafe7a620a509c32f6115"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14872926d65eafe7a620a509c32f6115">ev_get_autocmt</a> (self, 'insn_t const *' insn)</td></tr>
<tr class="separator:a14872926d65eafe7a620a509c32f6115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8dbacb923c08223dbed0f28738dc30" id="r_a6b8dbacb923c08223dbed0f28738dc30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b8dbacb923c08223dbed0f28738dc30">ev_get_bg_color</a> (self, 'bgcolor_t *' color, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:a6b8dbacb923c08223dbed0f28738dc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cc4b5d0f454f45540cd5635301850c" id="r_aa9cc4b5d0f454f45540cd5635301850c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9cc4b5d0f454f45540cd5635301850c">ev_is_jump_func</a> (self, 'func_t *' pfn, 'ea_t *' jump_target, 'ea_t *' func_pointer)</td></tr>
<tr class="separator:aa9cc4b5d0f454f45540cd5635301850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263686ecf6ad55e9c6f74700f026f283" id="r_a263686ecf6ad55e9c6f74700f026f283"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a263686ecf6ad55e9c6f74700f026f283">ev_func_bounds</a> (self, 'int *' possible_return_code, 'func_t *' pfn, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> max_func_end_ea)</td></tr>
<tr class="separator:a263686ecf6ad55e9c6f74700f026f283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b56925353ba57232ea93f5fa1ec344" id="r_a42b56925353ba57232ea93f5fa1ec344"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42b56925353ba57232ea93f5fa1ec344">ev_verify_sp</a> (self, 'func_t *' pfn)</td></tr>
<tr class="separator:a42b56925353ba57232ea93f5fa1ec344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dc9a44cc538494675b786cdc1000cf" id="r_ae5dc9a44cc538494675b786cdc1000cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5dc9a44cc538494675b786cdc1000cf">ev_verify_noreturn</a> (self, 'func_t *' pfn)</td></tr>
<tr class="separator:ae5dc9a44cc538494675b786cdc1000cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc7bf4ee0803a92ef72c04106be994" id="r_acefc7bf4ee0803a92ef72c04106be994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acefc7bf4ee0803a92ef72c04106be994">ev_create_func_frame</a> (self, 'func_t *' pfn)</td></tr>
<tr class="separator:acefc7bf4ee0803a92ef72c04106be994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5b8cabe60d1e1136f00c66a6abe0ff" id="r_aee5b8cabe60d1e1136f00c66a6abe0ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee5b8cabe60d1e1136f00c66a6abe0ff">ev_get_frame_retsize</a> (self, 'int *' frsize, 'func_t const *' pfn)</td></tr>
<tr class="separator:aee5b8cabe60d1e1136f00c66a6abe0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe3abbf262d746a500e544ed3f36b7f" id="r_a5fe3abbf262d746a500e544ed3f36b7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fe3abbf262d746a500e544ed3f36b7f">ev_get_stkvar_scale_factor</a> (self)</td></tr>
<tr class="separator:a5fe3abbf262d746a500e544ed3f36b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5f5b7541bde8ad757410373f787764" id="r_a6f5f5b7541bde8ad757410373f787764"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f5f5b7541bde8ad757410373f787764">ev_demangle_name</a> (self, str name, int disable_mask, int demreq)</td></tr>
<tr class="separator:a6f5f5b7541bde8ad757410373f787764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a4708fab54689ceb4a582fb355e1df" id="r_a91a4708fab54689ceb4a582fb355e1df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91a4708fab54689ceb4a582fb355e1df">ev_add_cref</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> _from, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> to, 'cref_t' type)</td></tr>
<tr class="separator:a91a4708fab54689ceb4a582fb355e1df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c7f8d837da76a769f0d499230a29a0" id="r_a91c7f8d837da76a769f0d499230a29a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91c7f8d837da76a769f0d499230a29a0">ev_add_dref</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> _from, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> to, 'dref_t' type)</td></tr>
<tr class="separator:a91c7f8d837da76a769f0d499230a29a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13724795b34d14e3f0d81a9e27285904" id="r_a13724795b34d14e3f0d81a9e27285904"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13724795b34d14e3f0d81a9e27285904">ev_del_cref</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> _from, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> to, bool expand)</td></tr>
<tr class="separator:a13724795b34d14e3f0d81a9e27285904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d8330b4031a4ded93ab6ac12140433" id="r_a10d8330b4031a4ded93ab6ac12140433"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10d8330b4031a4ded93ab6ac12140433">ev_del_dref</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> _from, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> to)</td></tr>
<tr class="separator:a10d8330b4031a4ded93ab6ac12140433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf91bc0d0dad665dd9051a53534f0740" id="r_acf91bc0d0dad665dd9051a53534f0740"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf91bc0d0dad665dd9051a53534f0740">ev_coagulate_dref</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> _from, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> to, bool may_define, 'ea_t *' code_ea)</td></tr>
<tr class="separator:acf91bc0d0dad665dd9051a53534f0740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c246e62234bf406e30fa2f508aefc35" id="r_a6c246e62234bf406e30fa2f508aefc35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c246e62234bf406e30fa2f508aefc35">ev_may_show_sreg</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> current_ea)</td></tr>
<tr class="separator:a6c246e62234bf406e30fa2f508aefc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08680c78b4749f8600c820b546786f8" id="r_ae08680c78b4749f8600c820b546786f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae08680c78b4749f8600c820b546786f8">ev_auto_queue_empty</a> (self, 'atype_t' type)</td></tr>
<tr class="separator:ae08680c78b4749f8600c820b546786f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a35c8903bce0bd03548d21275687dc" id="r_ac8a35c8903bce0bd03548d21275687dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8a35c8903bce0bd03548d21275687dc">ev_validate_flirt_func</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> start_ea, str funcname)</td></tr>
<tr class="separator:ac8a35c8903bce0bd03548d21275687dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e6d5946b42aaeb5138888a99f9fb35" id="r_aa8e6d5946b42aaeb5138888a99f9fb35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8e6d5946b42aaeb5138888a99f9fb35">ev_adjust_libfunc_ea</a> (self, 'idasgn_t const *' sig, 'libfunc_t const *' libfun, 'ea_t *' ea)</td></tr>
<tr class="separator:aa8e6d5946b42aaeb5138888a99f9fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac94618df317488af69193b9d3c5307" id="r_a3ac94618df317488af69193b9d3c5307"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ac94618df317488af69193b9d3c5307">ev_assemble</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> cs, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ip, bool use32, str line)</td></tr>
<tr class="separator:a3ac94618df317488af69193b9d3c5307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3274130606303d8aacee729226d51548" id="r_a3274130606303d8aacee729226d51548"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3274130606303d8aacee729226d51548">ev_extract_address</a> (self, 'ea_t *' out_ea, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> screen_ea, str string, 'size_t' position)</td></tr>
<tr class="separator:a3274130606303d8aacee729226d51548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b0a5572712973c86475579e319d655" id="r_a09b0a5572712973c86475579e319d655"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b0a5572712973c86475579e319d655">ev_realcvt</a> (self, 'void *' m, 'fpvalue_t *' e, 'uint16' swt)</td></tr>
<tr class="separator:a09b0a5572712973c86475579e319d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df0e8ffd1f184cd847b19968fefd0b8" id="r_a4df0e8ffd1f184cd847b19968fefd0b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df0e8ffd1f184cd847b19968fefd0b8">ev_gen_asm_or_lst</a> (self, bool starting, 'FILE *' fp, bool is_asm, int flags, 'html_line_cb_t **' outline)</td></tr>
<tr class="separator:a4df0e8ffd1f184cd847b19968fefd0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7c0946cb2b8beb40e42b6f5a9dc98e" id="r_a1b7c0946cb2b8beb40e42b6f5a9dc98e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b7c0946cb2b8beb40e42b6f5a9dc98e">ev_gen_map_file</a> (self, 'int *' nlines, 'FILE *' fp)</td></tr>
<tr class="separator:a1b7c0946cb2b8beb40e42b6f5a9dc98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd1cf29f470830390978d30af3c1ced" id="r_addd1cf29f470830390978d30af3c1ced"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd1cf29f470830390978d30af3c1ced">ev_create_flat_group</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> image_base, int bitness, 'sel_t' dataseg_sel)</td></tr>
<tr class="separator:addd1cf29f470830390978d30af3c1ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c89b85b472c0b68f78f921bee625369" id="r_a9c89b85b472c0b68f78f921bee625369"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c89b85b472c0b68f78f921bee625369">ev_getreg</a> (self, 'uval_t *' regval, int regnum)</td></tr>
<tr class="separator:a9c89b85b472c0b68f78f921bee625369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312fd8f157233f1456f280c0f5296de7" id="r_a312fd8f157233f1456f280c0f5296de7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a312fd8f157233f1456f280c0f5296de7">ev_analyze_prolog</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:a312fd8f157233f1456f280c0f5296de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cda2577365cf75b8922c97ed6ea0425" id="r_a8cda2577365cf75b8922c97ed6ea0425"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cda2577365cf75b8922c97ed6ea0425">ev_calc_spdelta</a> (self, 'sval_t *' spdelta, 'insn_t const *' insn)</td></tr>
<tr class="separator:a8cda2577365cf75b8922c97ed6ea0425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae471e79616af763a28bd7057b4895c5" id="r_aae471e79616af763a28bd7057b4895c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae471e79616af763a28bd7057b4895c5">ev_calcrel</a> (self)</td></tr>
<tr class="separator:aae471e79616af763a28bd7057b4895c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e4f40cde9d24ce8cd35c0b2041c589" id="r_ab3e4f40cde9d24ce8cd35c0b2041c589"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e4f40cde9d24ce8cd35c0b2041c589">ev_find_reg_value</a> (self, 'insn_t const *' pinsn, int reg)</td></tr>
<tr class="separator:ab3e4f40cde9d24ce8cd35c0b2041c589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01ec71d324cdfda58184a11fe6381c1" id="r_ae01ec71d324cdfda58184a11fe6381c1"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae01ec71d324cdfda58184a11fe6381c1">ev_find_op_value</a> (self, 'insn_t const *' pinsn, int opn)</td></tr>
<tr class="separator:ae01ec71d324cdfda58184a11fe6381c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a721c0bd85c93e04f5f9add45377f7" id="r_a58a721c0bd85c93e04f5f9add45377f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58a721c0bd85c93e04f5f9add45377f7">ev_replaying_undo</a> (self, str action_name, 'undo_records_t const *' vec, bool is_undo)</td></tr>
<tr class="separator:a58a721c0bd85c93e04f5f9add45377f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09c83e68badbb3c04c8e3aec3c5b058" id="r_aa09c83e68badbb3c04c8e3aec3c5b058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa09c83e68badbb3c04c8e3aec3c5b058">ev_ending_undo</a> (self, str action_name, bool is_undo)</td></tr>
<tr class="separator:aa09c83e68badbb3c04c8e3aec3c5b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67bc624c4e71be2d6ce07fc771a58a9" id="r_ae67bc624c4e71be2d6ce07fc771a58a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae67bc624c4e71be2d6ce07fc771a58a9">ev_set_code16_mode</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, bool code16)</td></tr>
<tr class="separator:ae67bc624c4e71be2d6ce07fc771a58a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf1821475d5cc282b58b648656d9f73" id="r_a3bf1821475d5cc282b58b648656d9f73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bf1821475d5cc282b58b648656d9f73">ev_get_code16_mode</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:a3bf1821475d5cc282b58b648656d9f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9a674c51c76cedee921f30309f5dc" id="r_a3fa9a674c51c76cedee921f30309f5dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa9a674c51c76cedee921f30309f5dc">ev_get_procmod</a> (self)</td></tr>
<tr class="separator:a3fa9a674c51c76cedee921f30309f5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22be892983c49b819da18c138778168" id="r_ae22be892983c49b819da18c138778168"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae22be892983c49b819da18c138778168">ev_asm_installed</a> (self, int asmnum)</td></tr>
<tr class="separator:ae22be892983c49b819da18c138778168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4b690433e2825be5982cf86b6f48c1" id="r_a7a4b690433e2825be5982cf86b6f48c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a4b690433e2825be5982cf86b6f48c1">ev_get_reg_accesses</a> (self, '<a class="el" href="classida__idp_1_1reg__accesses__t.html">reg_accesses_t</a>' accvec, 'insn_t const *' insn, int flags)</td></tr>
<tr class="separator:a7a4b690433e2825be5982cf86b6f48c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4badb24b6e181f593a888805a374dcb4" id="r_a4badb24b6e181f593a888805a374dcb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4badb24b6e181f593a888805a374dcb4">ev_is_control_flow_guard</a> (self, 'int *' p_reg, 'insn_t const *' insn)</td></tr>
<tr class="separator:a4badb24b6e181f593a888805a374dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f31bbe2e0802793e7c125ea6a3cb81" id="r_a32f31bbe2e0802793e7c125ea6a3cb81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32f31bbe2e0802793e7c125ea6a3cb81">ev_create_merge_handlers</a> (self, 'merge_data_t *' md)</td></tr>
<tr class="separator:a32f31bbe2e0802793e7c125ea6a3cb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ab19d863e8cb13341b151412b1de15" id="r_a75ab19d863e8cb13341b151412b1de15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75ab19d863e8cb13341b151412b1de15">ev_privrange_changed</a> (self, 'range_t' old_privrange, 'adiff_t' delta)</td></tr>
<tr class="separator:a75ab19d863e8cb13341b151412b1de15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af6482e529f952962da2a13a154b876" id="r_a3af6482e529f952962da2a13a154b876"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3af6482e529f952962da2a13a154b876">ev_cvt64_supval</a> (self, 'nodeidx_t' node, 'uchar' tag, 'nodeidx_t' idx, 'uchar const *' data)</td></tr>
<tr class="separator:a3af6482e529f952962da2a13a154b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fbf6d2ab13feec47106104b713ac4a" id="r_ae1fbf6d2ab13feec47106104b713ac4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1fbf6d2ab13feec47106104b713ac4a">ev_cvt64_hashval</a> (self, 'nodeidx_t' node, 'uchar' tag, str name, 'uchar const *' data)</td></tr>
<tr class="separator:ae1fbf6d2ab13feec47106104b713ac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b1676aebc7365ffe86fff257a7b96a" id="r_a51b1676aebc7365ffe86fff257a7b96a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51b1676aebc7365ffe86fff257a7b96a">ev_gen_stkvar_def</a> (self, 'outctx_t *' outctx, 'udm_t' stkvar, int v, 'tid_t' tid)</td></tr>
<tr class="separator:a51b1676aebc7365ffe86fff257a7b96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9475b3c89731aa5055306fb1c9672c" id="r_a2b9475b3c89731aa5055306fb1c9672c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b9475b3c89731aa5055306fb1c9672c">ev_next_exec_insn</a> (self, 'ea_t *' target, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, int tid, 'processor_t::regval_getter_t *' getreg, 'regval_t' regvalues)</td></tr>
<tr class="separator:a2b9475b3c89731aa5055306fb1c9672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44de66ddaa4e26a8d8e148293e201f70" id="r_a44de66ddaa4e26a8d8e148293e201f70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44de66ddaa4e26a8d8e148293e201f70">ev_calc_step_over</a> (self, 'ea_t *' target, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ip)</td></tr>
<tr class="separator:a44de66ddaa4e26a8d8e148293e201f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa037b428e4415c43c2658d63060137eb" id="r_aa037b428e4415c43c2658d63060137eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa037b428e4415c43c2658d63060137eb">ev_calc_next_eas</a> (self, 'eavec_t *' res, 'insn_t const *' insn, bool over)</td></tr>
<tr class="separator:aa037b428e4415c43c2658d63060137eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8429d28b83f0e6f464550ea64f4edac5" id="r_a8429d28b83f0e6f464550ea64f4edac5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8429d28b83f0e6f464550ea64f4edac5">ev_get_macro_insn_head</a> (self, 'ea_t *' head, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ip)</td></tr>
<tr class="separator:a8429d28b83f0e6f464550ea64f4edac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c52029898f918e3f08a7d40975ac54" id="r_a47c52029898f918e3f08a7d40975ac54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47c52029898f918e3f08a7d40975ac54">ev_get_dbr_opnum</a> (self, 'int *' opnum, 'insn_t const *' insn)</td></tr>
<tr class="separator:a47c52029898f918e3f08a7d40975ac54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2c97574380e1cb1ab46144cc3c729a" id="r_a8c2c97574380e1cb1ab46144cc3c729a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c2c97574380e1cb1ab46144cc3c729a">ev_insn_reads_tbit</a> (self, 'insn_t const *' insn, 'processor_t::regval_getter_t *' getreg, 'regval_t' regvalues)</td></tr>
<tr class="separator:a8c2c97574380e1cb1ab46144cc3c729a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeaac4a122b47df0ae4e30cca82785a7" id="r_adeaac4a122b47df0ae4e30cca82785a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeaac4a122b47df0ae4e30cca82785a7">ev_clean_tbit</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, 'processor_t::regval_getter_t *' getreg, 'regval_t' regvalues)</td></tr>
<tr class="separator:adeaac4a122b47df0ae4e30cca82785a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5969273acccc09c531c2565ad28dc7c" id="r_ab5969273acccc09c531c2565ad28dc7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5969273acccc09c531c2565ad28dc7c">ev_get_reg_info</a> (self, 'char const **' main_regname, 'bitrange_t' bitrange, str regname)</td></tr>
<tr class="separator:ab5969273acccc09c531c2565ad28dc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e39f1fa75fcdde17e4c107e2e322fe8" id="r_a7e39f1fa75fcdde17e4c107e2e322fe8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e39f1fa75fcdde17e4c107e2e322fe8">ev_update_call_stack</a> (self, 'call_stack_t' stack, int tid, 'processor_t::regval_getter_t *' getreg, 'regval_t' regvalues)</td></tr>
<tr class="separator:a7e39f1fa75fcdde17e4c107e2e322fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf80ba458c80353c7250ac1821ab84d" id="r_a2bf80ba458c80353c7250ac1821ab84d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bf80ba458c80353c7250ac1821ab84d">ev_setup_til</a> (self)</td></tr>
<tr class="separator:a2bf80ba458c80353c7250ac1821ab84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada73dbafe23d4b3253588a60e6c07979" id="r_ada73dbafe23d4b3253588a60e6c07979"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada73dbafe23d4b3253588a60e6c07979">ev_get_abi_info</a> (self, 'comp_t' comp)</td></tr>
<tr class="separator:ada73dbafe23d4b3253588a60e6c07979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78b1df2a11a06f0e86f9b73f65940a" id="r_a9e78b1df2a11a06f0e86f9b73f65940a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e78b1df2a11a06f0e86f9b73f65940a">ev_max_ptr_size</a> (self)</td></tr>
<tr class="separator:a9e78b1df2a11a06f0e86f9b73f65940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab949606f0c74f5509fc26a5840d3058b" id="r_ab949606f0c74f5509fc26a5840d3058b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab949606f0c74f5509fc26a5840d3058b">ev_get_default_enum_size</a> (self)</td></tr>
<tr class="separator:ab949606f0c74f5509fc26a5840d3058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4370eeca31cee02516eb881a2c92c5" id="r_abf4370eeca31cee02516eb881a2c92c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf4370eeca31cee02516eb881a2c92c5">ev_get_cc_regs</a> (self, 'callregs_t' regs, 'cm_t' cc)</td></tr>
<tr class="separator:abf4370eeca31cee02516eb881a2c92c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4117e379d83b28c49baddf8c8fbfbea6" id="r_a4117e379d83b28c49baddf8c8fbfbea6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4117e379d83b28c49baddf8c8fbfbea6">ev_get_simd_types</a> (self, 'simd_info_vec_t *' out, 'simd_info_t' simd_attrs, 'argloc_t' argloc, bool create_tifs)</td></tr>
<tr class="separator:a4117e379d83b28c49baddf8c8fbfbea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e07df37064989c7c10d5e697d4a95" id="r_ae45e07df37064989c7c10d5e697d4a95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae45e07df37064989c7c10d5e697d4a95">ev_calc_cdecl_purged_bytes</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea)</td></tr>
<tr class="separator:ae45e07df37064989c7c10d5e697d4a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09da244ce1a31f30249ce53f592d4da3" id="r_a09da244ce1a31f30249ce53f592d4da3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09da244ce1a31f30249ce53f592d4da3">ev_calc_purged_bytes</a> (self, 'int *' p_purged_bytes, 'func_type_data_t' fti)</td></tr>
<tr class="separator:a09da244ce1a31f30249ce53f592d4da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7814ab0b00618f9bbac8611b7a02cb6c" id="r_a7814ab0b00618f9bbac8611b7a02cb6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7814ab0b00618f9bbac8611b7a02cb6c">ev_calc_retloc</a> (self, 'argloc_t' retloc, 'tinfo_t' rettype, 'cm_t' cc)</td></tr>
<tr class="separator:a7814ab0b00618f9bbac8611b7a02cb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ae5231f664b8d83a1ee14a9f00498" id="r_a831ae5231f664b8d83a1ee14a9f00498"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831ae5231f664b8d83a1ee14a9f00498">ev_calc_arglocs</a> (self, 'func_type_data_t' fti)</td></tr>
<tr class="separator:a831ae5231f664b8d83a1ee14a9f00498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678aee39f5e585402c0f19d68ee14d1a" id="r_a678aee39f5e585402c0f19d68ee14d1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a678aee39f5e585402c0f19d68ee14d1a">ev_calc_varglocs</a> (self, 'func_type_data_t' ftd, 'regobjs_t' aux_regs, 'relobj_t' aux_stkargs, int nfixed)</td></tr>
<tr class="separator:a678aee39f5e585402c0f19d68ee14d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee7c91beb6ad45bf7b22e1af6dee1f6" id="r_a4ee7c91beb6ad45bf7b22e1af6dee1f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ee7c91beb6ad45bf7b22e1af6dee1f6">ev_adjust_argloc</a> (self, 'argloc_t' argloc, 'tinfo_t' optional_type, int size)</td></tr>
<tr class="separator:a4ee7c91beb6ad45bf7b22e1af6dee1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd4747537c6b1bfc6aae3d0510a4463" id="r_aabd4747537c6b1bfc6aae3d0510a4463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabd4747537c6b1bfc6aae3d0510a4463">ev_lower_func_type</a> (self, 'intvec_t *' argnums, 'func_type_data_t' fti)</td></tr>
<tr class="separator:aabd4747537c6b1bfc6aae3d0510a4463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1fb6607d9487d07d0e0eb99fdb7d2c" id="r_a3c1fb6607d9487d07d0e0eb99fdb7d2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c1fb6607d9487d07d0e0eb99fdb7d2c">ev_equal_reglocs</a> (self, 'argloc_t' a1, 'argloc_t' a2)</td></tr>
<tr class="separator:a3c1fb6607d9487d07d0e0eb99fdb7d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaa77d23a1743ce9849a45b14d0e689" id="r_adcaa77d23a1743ce9849a45b14d0e689"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcaa77d23a1743ce9849a45b14d0e689">ev_use_stkarg_type</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, 'funcarg_t' arg)</td></tr>
<tr class="separator:adcaa77d23a1743ce9849a45b14d0e689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750ebe872882db7319bf885bc0007555" id="r_a750ebe872882db7319bf885bc0007555"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750ebe872882db7319bf885bc0007555">ev_use_regarg_type</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, 'funcargvec_t const *' rargs)</td></tr>
<tr class="separator:a750ebe872882db7319bf885bc0007555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86016b6db5b48878221663def1d9e8c" id="r_ab86016b6db5b48878221663def1d9e8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab86016b6db5b48878221663def1d9e8c">ev_use_arg_types</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> ea, 'func_type_data_t' fti, 'funcargvec_t *' rargs)</td></tr>
<tr class="separator:ab86016b6db5b48878221663def1d9e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d9242fe8b4d0e06ae7040ff62061b6" id="r_a23d9242fe8b4d0e06ae7040ff62061b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23d9242fe8b4d0e06ae7040ff62061b6">ev_arg_addrs_ready</a> (self, <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a> caller, int n, 'tinfo_t' tif, 'ea_t *' addrs)</td></tr>
<tr class="separator:a23d9242fe8b4d0e06ae7040ff62061b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c1c828d0050fe9b695bbd64a3e5856" id="r_a97c1c828d0050fe9b695bbd64a3e5856"><td class="memItemLeft" align="right" valign="top">'PyObject *'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c1c828d0050fe9b695bbd64a3e5856">ev_decorate_name</a> (self, str name, bool mangle, int cc, 'tinfo_t' optional_type)</td></tr>
<tr class="separator:a97c1c828d0050fe9b695bbd64a3e5856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf13e3e9744da49dcf45805454b8dba" id="r_acbf13e3e9744da49dcf45805454b8dba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbf13e3e9744da49dcf45805454b8dba">ev_arch_changed</a> (self)</td></tr>
<tr class="separator:acbf13e3e9744da49dcf45805454b8dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fca6346b383ac7473a6302b36698d9d" id="r_a9fca6346b383ac7473a6302b36698d9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fca6346b383ac7473a6302b36698d9d">ev_get_stkarg_area_info</a> (self, 'stkarg_area_info_t' out, 'cm_t' cc)</td></tr>
<tr class="separator:a9fca6346b383ac7473a6302b36698d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca7dd82b8f8a0d7c1c35f9629a73857" id="r_afca7dd82b8f8a0d7c1c35f9629a73857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afca7dd82b8f8a0d7c1c35f9629a73857">ev_last_cb_before_loader</a> (self)</td></tr>
<tr class="separator:afca7dd82b8f8a0d7c1c35f9629a73857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f8168609705f3db1855510c8fe6ae3" id="r_ae2f8168609705f3db1855510c8fe6ae3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2f8168609705f3db1855510c8fe6ae3">ev_loader</a> (self)</td></tr>
<tr class="separator:ae2f8168609705f3db1855510c8fe6ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943173074d26d1fa0aec474cb0721041" id="r_a943173074d26d1fa0aec474cb0721041"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a943173074d26d1fa0aec474cb0721041">__disown__</a> (self)</td></tr>
<tr class="separator:a943173074d26d1fa0aec474cb0721041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a50e9fbdd6a13e9e50cfba34656086bb6" id="r_a50e9fbdd6a13e9e50cfba34656086bb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50e9fbdd6a13e9e50cfba34656086bb6">thisown</a></td></tr>
<tr class="separator:a50e9fbdd6a13e9e50cfba34656086bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a226b4b6da90e3cb1943cdc1416170446" name="a226b4b6da90e3cb1943cdc1416170446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226b4b6da90e3cb1943cdc1416170446">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__init__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_hkcb_flags</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classida__idp_1_1__notify__when__dispatcher__t_1_1___i_d_p___hooks.html#a6ddcf05d7f9689f9d03594010934f092">_notify_when_dispatcher_t._IDP_Hooks</a>, and <a class="el" href="classida__idp_1_1processor__t.html#abdd362d5f799ad16b5d6700efe590290">processor_t</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a943173074d26d1fa0aec474cb0721041" name="a943173074d26d1fa0aec474cb0721041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943173074d26d1fa0aec474cb0721041">&#9670;&#160;</a></span>__disown__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__disown__ </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a91a4708fab54689ceb4a582fb355e1df" name="a91a4708fab54689ceb4a582fb355e1df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a4708fab54689ceb4a582fb355e1df">&#9670;&#160;</a></span>ev_add_cref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_add_cref </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>_from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'cref_t'</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A code reference is being created. 
  
@param to: (::ea_t)
@param type: (cref_t)
@retval &lt;0: cancel cref creation
@retval 0: not implemented or continue</pre> 
</div>
</div>
<a id="a91c7f8d837da76a769f0d499230a29a0" name="a91c7f8d837da76a769f0d499230a29a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c7f8d837da76a769f0d499230a29a0">&#9670;&#160;</a></span>ev_add_dref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_add_dref </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>_from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'dref_t'</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A data reference is being created. 
  
@param to: (::ea_t)
@param type: (dref_t)
@retval &lt;0: cancel dref creation
@retval 0: not implemented or continue</pre> 
</div>
</div>
<a id="a4ee7c91beb6ad45bf7b22e1af6dee1f6" name="a4ee7c91beb6ad45bf7b22e1af6dee1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee7c91beb6ad45bf7b22e1af6dee1f6">&#9670;&#160;</a></span>ev_adjust_argloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_adjust_argloc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'argloc_t'</td>          <td class="paramname"><span class="paramname"><em>argloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'tinfo_t'</td>          <td class="paramname"><span class="paramname"><em>optional_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adjust argloc according to its type/size and platform endianess 
  
@param argloc: (argloc_t *), inout
@param size: (int) 'size' makes no sense if type != nullptr (type-&gt;get_size() should be used instead)
@retval 0: not implemented
@retval 1: ok
@retval -1: error</pre> 
</div>
</div>
<a id="aa8e6d5946b42aaeb5138888a99f9fb35" name="aa8e6d5946b42aaeb5138888a99f9fb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e6d5946b42aaeb5138888a99f9fb35">&#9670;&#160;</a></span>ev_adjust_libfunc_ea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_adjust_libfunc_ea </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'idasgn_t const *'</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'libfunc_t const *'</td>          <td class="paramname"><span class="paramname"><em>libfun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called when a signature module has been matched against bytes in the database. This is used to compute the offset at which a particular module's libfunc should be applied. 
  
@param sig: (const idasgn_t *)
@param libfun: (const libfunc_t *)
@param ea: (::ea_t *)
@retval 1: the ea_t pointed to by the third argument was modified.
@retval &lt;=0: not modified. use default algorithm.</pre> 
</div>
</div>
<a id="a605fb2709cf5611cb4198335d5349b8e" name="a605fb2709cf5611cb4198335d5349b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605fb2709cf5611cb4198335d5349b8e">&#9670;&#160;</a></span>ev_adjust_refinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_adjust_refinfo </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'refinfo_t'</td>          <td class="paramname"><span class="paramname"><em>ri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'fixup_data_t const *'</td>          <td class="paramname"><span class="paramname"><em>fd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called from apply_fixup before converting operand to reference. Can be used for changing the reference info. (e.g. the PPC module adds REFINFO_NOBASE for some references) 
  
@param ri: (refinfo_t *)
@param ea: (::ea_t) instruction address
@param n: (int) operand number
@param fd: (const fixup_data_t *)
@retval &lt;0: do not create an offset
@retval 0: not implemented or refinfo adjusted</pre> 
</div>
</div>
<a id="abf449162425148644af2032812c67acf" name="abf449162425148644af2032812c67acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf449162425148644af2032812c67acf">&#9670;&#160;</a></span>ev_ana_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev_ana_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t *'</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Analyze one instruction and fill 'out' structure. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. insn_t::ea contains address of instruction to analyze. 
  
@param out: (insn_t *)
@returns length of the instruction in bytes, 0 if instruction can't be decoded.
@retval 0: if instruction can't be decoded.</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a3f0390feb44df7d708b60c5ca1856e8b">processor_t</a>.</p>

</div>
</div>
<a id="a312fd8f157233f1456f280c0f5296de7" name="a312fd8f157233f1456f280c0f5296de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312fd8f157233f1456f280c0f5296de7">&#9670;&#160;</a></span>ev_analyze_prolog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_analyze_prolog </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Analyzes function prolog, epilog, and updates purge, and function attributes 
  
@param ea: (::ea_t) start of function
@retval 1: ok
@retval 0: not implemented</pre> 
</div>
</div>
<a id="acbf13e3e9744da49dcf45805454b8dba" name="acbf13e3e9744da49dcf45805454b8dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf13e3e9744da49dcf45805454b8dba">&#9670;&#160;</a></span>ev_arch_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_arch_changed </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The loader is done parsing arch-related information, which the processor module might want to use to finish its initialization. 
  
@retval 1: if success
@retval 0: not implemented or failed</pre> 
</div>
</div>
<a id="a23d9242fe8b4d0e06ae7040ff62061b6" name="a23d9242fe8b4d0e06ae7040ff62061b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d9242fe8b4d0e06ae7040ff62061b6">&#9670;&#160;</a></span>ev_arg_addrs_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_arg_addrs_ready </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>caller</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'tinfo_t'</td>          <td class="paramname"><span class="paramname"><em>tif</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>addrs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Argument address info is ready. 
  
@param caller: (::ea_t)
@param n: (int) number of formal arguments
@param tif: (tinfo_t *) call prototype
@param addrs: (::ea_t *) argument intilization addresses
@retval &lt;0: do not save into idb; other values mean "ok to save\"</pre> 
</div>
</div>
<a id="ae22be892983c49b819da18c138778168" name="ae22be892983c49b819da18c138778168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22be892983c49b819da18c138778168">&#9670;&#160;</a></span>ev_asm_installed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_asm_installed </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>asmnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">After setting a new assembler 
  
@param asmnum: (int) See also ev_newasm</pre> 
</div>
</div>
<a id="a3ac94618df317488af69193b9d3c5307" name="a3ac94618df317488af69193b9d3c5307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac94618df317488af69193b9d3c5307">&#9670;&#160;</a></span>ev_assemble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_assemble </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ip</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assemble an instruction. (display a warning if an error is found). 
  
@param ea: (::ea_t) linear address of instruction
@param cs: (::ea_t) cs of instruction
@param ip: (::ea_t) ip of instruction
@param use32: (bool) is 32bit segment?
@param line: (const char *) line to assemble
@returns size of the instruction in bytes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a4300955a5ccca026926acf4e39b93032">processor_t</a>.</p>

</div>
</div>
<a id="ae08680c78b4749f8600c820b546786f8" name="ae08680c78b4749f8600c820b546786f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08680c78b4749f8600c820b546786f8">&#9670;&#160;</a></span>ev_auto_queue_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_auto_queue_empty </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'atype_t'</td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">One analysis queue is empty. 
  
@param type: (atype_t)
@retval void: see also idb_event::auto_empty_finally</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a79290c6afb2fe6d7a53cc09924f98f7a">processor_t</a>.</p>

</div>
</div>
<a id="a831ae5231f664b8d83a1ee14a9f00498" name="a831ae5231f664b8d83a1ee14a9f00498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831ae5231f664b8d83a1ee14a9f00498">&#9670;&#160;</a></span>ev_calc_arglocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_arglocs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_type_data_t'</td>          <td class="paramname"><span class="paramname"><em>fti</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate function argument locations. This callback should fill retloc, all arglocs, and stkargs. This callback is never called for CM_CC_SPECIAL functions. 
  
@param fti: (func_type_data_t *) points to the func type info
@retval 0: not implemented
@retval 1: ok
@retval -1: error</pre> 
</div>
</div>
<a id="ae45e07df37064989c7c10d5e697d4a95" name="ae45e07df37064989c7c10d5e697d4a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45e07df37064989c7c10d5e697d4a95">&#9670;&#160;</a></span>ev_calc_cdecl_purged_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_cdecl_purged_bytes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate number of purged bytes after call. 
  
@param ea: (::ea_t) address of the call instruction
@returns number of purged bytes (usually add sp, N)</pre> 
</div>
</div>
<a id="aa037b428e4415c43c2658d63060137eb" name="aa037b428e4415c43c2658d63060137eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa037b428e4415c43c2658d63060137eb">&#9670;&#160;</a></span>ev_calc_next_eas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_next_eas </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'eavec_t *'</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>over</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate list of addresses the instruction in 'insn' may pass control to. This callback is required for source level debugging. 
  
@param res: (eavec_t *), out: array for the results.
@param insn: (const insn_t*) the instruction
@param over: (bool) calculate for step over (ignore call targets)
@retval &lt;0: incalculable (indirect jumps, for example)
@retval &gt;=0: number of addresses of called functions in the array. They must be put at the beginning of the array (0 if over=true)</pre> 
</div>
</div>
<a id="a09da244ce1a31f30249ce53f592d4da3" name="a09da244ce1a31f30249ce53f592d4da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09da244ce1a31f30249ce53f592d4da3">&#9670;&#160;</a></span>ev_calc_purged_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_purged_bytes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>p_purged_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'func_type_data_t'</td>          <td class="paramname"><span class="paramname"><em>fti</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate number of purged bytes by the given function type. 
  
@param p_purged_bytes: (int *) ptr to output
@param fti: (const func_type_data_t *) func type details
@retval 1: 
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a7814ab0b00618f9bbac8611b7a02cb6c" name="a7814ab0b00618f9bbac8611b7a02cb6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7814ab0b00618f9bbac8611b7a02cb6c">&#9670;&#160;</a></span>ev_calc_retloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_retloc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'argloc_t'</td>          <td class="paramname"><span class="paramname"><em>retloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'tinfo_t'</td>          <td class="paramname"><span class="paramname"><em>rettype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'cm_t'
        </td>          <td class="paramname"><span class="paramname"><em>cc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate return value location. 
  
@param retloc: (argloc_t *)
@param rettype: (const tinfo_t *)
@param cc: (cm_t)
@retval 0: not implemented
@retval 1: ok,
@retval -1: error</pre> 
</div>
</div>
<a id="a8cda2577365cf75b8922c97ed6ea0425" name="a8cda2577365cf75b8922c97ed6ea0425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cda2577365cf75b8922c97ed6ea0425">&#9670;&#160;</a></span>ev_calc_spdelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_spdelta </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'sval_t *'</td>          <td class="paramname"><span class="paramname"><em>spdelta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'
        </td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate amount of change to sp for the given insn. This event is required to decompile code snippets. 
  
@param spdelta: (sval_t *)
@param insn: (const insn_t *)
@retval 1: ok
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a44de66ddaa4e26a8d8e148293e201f70" name="a44de66ddaa4e26a8d8e148293e201f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44de66ddaa4e26a8d8e148293e201f70">&#9670;&#160;</a></span>ev_calc_step_over()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_step_over </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ip</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the address of the instruction which will be executed after "step over". The kernel will put a breakpoint there. If the step over is equal to step into or we cannot calculate the address, return BADADDR. 
  
@param target: (::ea_t *) pointer to the answer
@param ip: (::ea_t) instruction address
@retval 0: unimplemented
@retval 1: implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#abfd3de89e71dd67adede0129238e9c20">processor_t</a>.</p>

</div>
</div>
<a id="ad09c3f1b589292c72a69bb7292d3ea7a" name="ad09c3f1b589292c72a69bb7292d3ea7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09c3f1b589292c72a69bb7292d3ea7a">&#9670;&#160;</a></span>ev_calc_switch_cases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_switch_cases </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'casevec_t *'</td>          <td class="paramname"><span class="paramname"><em>casevec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'eavec_t *'</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>insn_ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'switch_info_t'</td>          <td class="paramname"><span class="paramname"><em>si</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate case values and targets for a custom jump table. 
  
@param casevec: (::casevec_t *) vector of case values (may be nullptr)
@param targets: (eavec_t *) corresponding target addresses (my be nullptr)
@param insn_ea: (::ea_t) address of the 'indirect jump' instruction
@param si: (switch_info_t *) switch information
@retval 1: ok
@retval &lt;=0: failed</pre> 
</div>
</div>
<a id="a678aee39f5e585402c0f19d68ee14d1a" name="a678aee39f5e585402c0f19d68ee14d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678aee39f5e585402c0f19d68ee14d1a">&#9670;&#160;</a></span>ev_calc_varglocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calc_varglocs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_type_data_t'</td>          <td class="paramname"><span class="paramname"><em>ftd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'regobjs_t'</td>          <td class="paramname"><span class="paramname"><em>aux_regs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'relobj_t'</td>          <td class="paramname"><span class="paramname"><em>aux_stkargs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nfixed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate locations of the arguments that correspond to '...'. 
  
@param ftd: (func_type_data_t *), inout: info about all arguments (including varargs)
@param aux_regs: (regobjs_t *) buffer for hidden register arguments, may be nullptr
@param aux_stkargs: (relobj_t *) buffer for hidden stack arguments, may be nullptr
@param nfixed: (int) number of fixed arguments
@retval 0: not implemented
@retval 1: ok
@retval -1: error On some platforms variadic calls require passing additional information: for example, number of floating variadic arguments must be passed in rax on gcc-x64. The locations and values that constitute this additional information are returned in the buffers pointed by aux_regs and aux_stkargs</pre> 
</div>
</div>
<a id="aae471e79616af763a28bd7057b4895c5" name="aae471e79616af763a28bd7057b4895c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae471e79616af763a28bd7057b4895c5">&#9670;&#160;</a></span>ev_calcrel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_calcrel </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reserved.
</pre> 
</div>
</div>
<a id="a171fe442670e90f9ba8ada8cc8c9fee3" name="a171fe442670e90f9ba8ada8cc8c9fee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171fe442670e90f9ba8ada8cc8c9fee3">&#9670;&#160;</a></span>ev_can_have_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_can_have_type </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'op_t const *'</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Can the operand have a type as offset, segment, decimal, etc? (for example, a register AX can't have a type, meaning that the user can't change its representation. see bytes.hpp for information about types and flags) 
  
@param op: (const op_t *)
@retval 0: unknown
@retval &lt;0: no
@retval 1: yes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#abbbb3400d6764d3a40c1a49cc23f2159">processor_t</a>.</p>

</div>
</div>
<a id="adeaac4a122b47df0ae4e30cca82785a7" name="adeaac4a122b47df0ae4e30cca82785a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaac4a122b47df0ae4e30cca82785a7">&#9670;&#160;</a></span>ev_clean_tbit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_clean_tbit </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'processor_t.regval_getter_t *'</td>          <td class="paramname"><span class="paramname"><em>getreg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'regval_t'</td>          <td class="paramname"><span class="paramname"><em>regvalues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Clear the TF bit after an insn like pushf stored it in memory. 
  
@param ea: (::ea_t) instruction address
@param getreg: (::processor_t::regval_getter_t *) function to get register values
@param regvalues: (const regval_t *) register values array
@retval 1: ok
@retval 0: failed</pre> 
</div>
</div>
<a id="a2d56f8f59be2491dc5e9361f44e368b7" name="a2d56f8f59be2491dc5e9361f44e368b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d56f8f59be2491dc5e9361f44e368b7">&#9670;&#160;</a></span>ev_cmp_operands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_cmp_operands </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'op_t const *'</td>          <td class="paramname"><span class="paramname"><em>op1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'op_t const *'</td>          <td class="paramname"><span class="paramname"><em>op2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compare instruction operands 
  
@param op1: (const op_t*)
@param op2: (const op_t*)
@retval 1: equal
@retval -1: not equal
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#abbf203f2d9adfd2947285f8913cb0298">processor_t</a>.</p>

</div>
</div>
<a id="aa343c6918b624e6d2bfda32d510351ad" name="aa343c6918b624e6d2bfda32d510351ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa343c6918b624e6d2bfda32d510351ad">&#9670;&#160;</a></span>ev_coagulate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_coagulate </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>start_ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to define some unexplored bytes. This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. 
  
@param start_ea: (::ea_t)
@returns number of converted bytes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a0f2b1a71b27fbd6766c5b506a79ccd3c">processor_t</a>.</p>

</div>
</div>
<a id="acf91bc0d0dad665dd9051a53534f0740" name="acf91bc0d0dad665dd9051a53534f0740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf91bc0d0dad665dd9051a53534f0740">&#9670;&#160;</a></span>ev_coagulate_dref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_coagulate_dref </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>_from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>may_define</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>code_ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Data reference is being analyzed. plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) 
  
@param to: (::ea_t)
@param may_define: (bool)
@param code_ea: (::ea_t *)
@retval &lt;0: failed dref analysis, &gt;0 done dref analysis
@retval 0: not implemented or continue</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a171688c47a9ecedd0cfb4cc4a9949b75">processor_t</a>.</p>

</div>
</div>
<a id="addd1cf29f470830390978d30af3c1ced" name="addd1cf29f470830390978d30af3c1ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd1cf29f470830390978d30af3c1ced">&#9670;&#160;</a></span>ev_create_flat_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_create_flat_group </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>image_base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        int</td>          <td class="paramname"><span class="paramname"><em>bitness</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'sel_t'</td>          <td class="paramname"><span class="paramname"><em>dataseg_sel</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create special segment representing the flat group. 
  
@param image_base: (::ea_t)
@param bitness: (int)
@param dataseg_sel: (::sel_t) return value is ignored</pre> 
</div>
</div>
<a id="acefc7bf4ee0803a92ef72c04106be994" name="acefc7bf4ee0803a92ef72c04106be994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefc7bf4ee0803a92ef72c04106be994">&#9670;&#160;</a></span>ev_create_func_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_create_func_frame </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_t *'</td>          <td class="paramname"><span class="paramname"><em>pfn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a function frame for a newly created function Set up frame size, its attributes etc 
  
@param pfn: (func_t *)
@retval 1: ok
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a6175491b16bc7db07779ceae357f2895">processor_t</a>.</p>

</div>
</div>
<a id="a32f31bbe2e0802793e7c125ea6a3cb81" name="a32f31bbe2e0802793e7c125ea6a3cb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f31bbe2e0802793e7c125ea6a3cb81">&#9670;&#160;</a></span>ev_create_merge_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_create_merge_handlers </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'merge_data_t *'</td>          <td class="paramname"><span class="paramname"><em>md</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create merge handlers, if needed 
  
@param md: (merge_data_t *) This event is generated immediately after opening idbs.
@returns must be 0</pre> 
</div>
</div>
<a id="a2e6eddda5ae830e4c797be38feaed952" name="a2e6eddda5ae830e4c797be38feaed952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6eddda5ae830e4c797be38feaed952">&#9670;&#160;</a></span>ev_create_switch_xrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_create_switch_xrefs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>jumpea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'switch_info_t'</td>          <td class="paramname"><span class="paramname"><em>si</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create xrefs for a custom jump table. 
  
@param jumpea: (::ea_t) address of the jump insn
@param si: (const switch_info_t *) switch information
@returns must return 1 Must be implemented if module uses custom jump tables, SWI_CUSTOM</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#ac49f5a82de799884c43f86613fe5a525">processor_t</a>.</p>

</div>
</div>
<a id="abbd6732c1a7bfc47c836f0c140d188c8" name="abbd6732c1a7bfc47c836f0c140d188c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd6732c1a7bfc47c836f0c140d188c8">&#9670;&#160;</a></span>ev_creating_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_creating_segm </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'segment_t *'</td>          <td class="paramname"><span class="paramname"><em>seg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A new segment is about to be created. 
  
@param seg: (segment_t *)
@retval 1: ok
@retval &lt;0: segment should not be created</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#aefa93dd6cc47a5276ed2500952000716">processor_t</a>.</p>

</div>
</div>
<a id="ae1fbf6d2ab13feec47106104b713ac4a" name="ae1fbf6d2ab13feec47106104b713ac4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1fbf6d2ab13feec47106104b713ac4a">&#9670;&#160;</a></span>ev_cvt64_hashval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_cvt64_hashval </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'nodeidx_t'</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uchar'</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uchar const *'</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">perform 32-64 conversion for a hash value 
  
@param node: (::nodeidx_t)
@param tag: (uchar)
@param name: (const ::char *)
@param data: (const uchar *)
@retval 0: nothing was done
@retval 1: converted successfully
@retval -1: error (and message in errbuf)</pre> 
</div>
</div>
<a id="a3af6482e529f952962da2a13a154b876" name="a3af6482e529f952962da2a13a154b876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af6482e529f952962da2a13a154b876">&#9670;&#160;</a></span>ev_cvt64_supval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_cvt64_supval </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'nodeidx_t'</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uchar'</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'nodeidx_t'</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uchar const *'</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">perform 32-64 conversion for a netnode array element 
  
@param node: (::nodeidx_t)
@param tag: (uchar)
@param idx: (::nodeidx_t)
@param data: (const uchar *)
@retval 0: nothing was done
@retval 1: converted successfully
@retval -1: error (and message in errbuf)</pre> 
</div>
</div>
<a id="a97c1c828d0050fe9b695bbd64a3e5856" name="a97c1c828d0050fe9b695bbd64a3e5856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c1c828d0050fe9b695bbd64a3e5856">&#9670;&#160;</a></span>ev_decorate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_decorate_name </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>mangle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'tinfo_t'</td>          <td class="paramname"><span class="paramname"><em>optional_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decorate/undecorate a C symbol name. 
  
@param name: (const char *) name of symbol
@param mangle: (bool) true-mangle, false-unmangle
@param cc: (cm_t) calling convention
@retval 1: if success
@retval 0: not implemented or failed</pre> 
</div>
</div>
<a id="a13724795b34d14e3f0d81a9e27285904" name="a13724795b34d14e3f0d81a9e27285904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13724795b34d14e3f0d81a9e27285904">&#9670;&#160;</a></span>ev_del_cref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_del_cref </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>_from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>expand</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A code reference is being deleted. 
  
@param to: (::ea_t)
@param expand: (bool)
@retval &lt;0: cancel cref deletion
@retval 0: not implemented or continue</pre> 
</div>
</div>
<a id="a10d8330b4031a4ded93ab6ac12140433" name="a10d8330b4031a4ded93ab6ac12140433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d8330b4031a4ded93ab6ac12140433">&#9670;&#160;</a></span>ev_del_dref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_del_dref </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>_from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A data reference is being deleted. 
  
@param to: (::ea_t)
@retval &lt;0: cancel dref deletion
@retval 0: not implemented or continue</pre> 
</div>
</div>
<a id="a82b59495a2126cae40842c94e209ed75" name="a82b59495a2126cae40842c94e209ed75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b59495a2126cae40842c94e209ed75">&#9670;&#160;</a></span>ev_delay_slot_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_delay_slot_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bexec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
        </td>          <td class="paramname"><span class="paramname"><em>fexec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get delay slot instruction 
  
@param ea: (::ea_t *) in: instruction address in question, out: (if the answer is positive) if the delay slot contains valid insn: the address of the delay slot insn else: BADADDR (invalid insn, e.g. a branch)
@param bexec: (bool *) execute slot if jumping, initially set to 'true'
@param fexec: (bool *) execute slot if not jumping, initally set to 'true'
@retval 1: positive answer
@retval &lt;=0: ordinary insn</pre> 
</div>
</div>
<a id="a6f5f5b7541bde8ad757410373f787764" name="a6f5f5b7541bde8ad757410373f787764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5f5b7541bde8ad757410373f787764">&#9670;&#160;</a></span>ev_demangle_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_demangle_name </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>disable_mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
        </td>          <td class="paramname"><span class="paramname"><em>demreq</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Demangle a C++ (or another language) name into a user-readable string. This event is called by demangle_name() 
  
@param name: (const char *) mangled name
@param disable_mask: (uint32) flags to inhibit parts of output or compiler info/other (see MNG_)
@param demreq: (demreq_type_t) operation to perform
@retval 1: if success
@retval 0: not implemented</pre> 
</div>
</div>
<a id="ac4023cbeedf97e05de8fa5af1e9e8698" name="ac4023cbeedf97e05de8fa5af1e9e8698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4023cbeedf97e05de8fa5af1e9e8698">&#9670;&#160;</a></span>ev_emu_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev_emu_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. Upon entrance to this function, all information about the instruction is in 'insn' structure. 
  
@param insn: (const insn_t *)
@retval 1: ok
@retval -1: the kernel will delete the instruction</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a9ac817536d4e0b3b085ff0592bb4c0ce">processor_t</a>.</p>

</div>
</div>
<a id="a3368d055da959872d3a9e8fb6bde547b" name="a3368d055da959872d3a9e8fb6bde547b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3368d055da959872d3a9e8fb6bde547b">&#9670;&#160;</a></span>ev_endbinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_endbinary </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ok</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">IDA has loaded a binary file. 
  
@param ok: (bool) file loaded successfully?</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a48e65f1afc227704fa384ab2b09d2d9b">processor_t</a>.</p>

</div>
</div>
<a id="aa09c83e68badbb3c04c8e3aec3c5b058" name="aa09c83e68badbb3c04c8e3aec3c5b058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09c83e68badbb3c04c8e3aec3c5b058">&#9670;&#160;</a></span>ev_ending_undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_ending_undo </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>action_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_undo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Ended undoing/redoing an action 
  
@param action_name: (const char *) action that we finished undoing/redoing. is not nullptr.
@param is_undo: (bool) true if performing undo, false if performing redo</pre> 
</div>
</div>
<a id="a3c1fb6607d9487d07d0e0eb99fdb7d2c" name="a3c1fb6607d9487d07d0e0eb99fdb7d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1fb6607d9487d07d0e0eb99fdb7d2c">&#9670;&#160;</a></span>ev_equal_reglocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_equal_reglocs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'argloc_t'</td>          <td class="paramname"><span class="paramname"><em>a1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'argloc_t'</td>          <td class="paramname"><span class="paramname"><em>a2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Are 2 register arglocs the same?. We need this callback for the pc module. 
  
@param a1: (argloc_t *)
@param a2: (argloc_t *)
@retval 1: yes
@retval -1: no
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a3274130606303d8aacee729226d51548" name="a3274130606303d8aacee729226d51548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3274130606303d8aacee729226d51548">&#9670;&#160;</a></span>ev_extract_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_extract_address </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>out_ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        <a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>screen_ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'size_t'</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Extract address from a string. 
  
@param out_ea: (ea_t *), out
@param screen_ea: (ea_t)
@param string: (const char *)
@param position: (size_t)
@retval 1: ok
@retval 0: kernel should use the standard algorithm
@retval -1: error</pre> 
</div>
</div>
<a id="ae01ec71d324cdfda58184a11fe6381c1" name="ae01ec71d324cdfda58184a11fe6381c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01ec71d324cdfda58184a11fe6381c1">&#9670;&#160;</a></span>ev_find_op_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_find_op_value </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>pinsn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
        </td>          <td class="paramname"><span class="paramname"><em>opn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find operand value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
  
@param pinsn: (const insn_t *) instruction
@param opn: (int) operand index
@retval 1: if implemented, and value was found
@retval 0: not implemented, -1 decoding failed, or no value found</pre> 
</div>
</div>
<a id="ab3e4f40cde9d24ce8cd35c0b2041c589" name="ab3e4f40cde9d24ce8cd35c0b2041c589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e4f40cde9d24ce8cd35c0b2041c589">&#9670;&#160;</a></span>ev_find_reg_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_find_reg_value </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>pinsn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
        </td>          <td class="paramname"><span class="paramname"><em>reg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find register value via a register tracker. The returned value in 'out' is valid before executing the instruction. 
  
@param pinsn: (const insn_t *) instruction
@param reg: (int) register index
@retval 1: if implemented, and value was found
@retval 0: not implemented, -1 decoding failed, or no value found</pre> 
</div>
</div>
<a id="a263686ecf6ad55e9c6f74700f026f283" name="a263686ecf6ad55e9c6f74700f026f283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263686ecf6ad55e9c6f74700f026f283">&#9670;&#160;</a></span>ev_func_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_func_bounds </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>possible_return_code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_t *'</td>          <td class="paramname"><span class="paramname"><em>pfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>max_func_end_ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">find_func_bounds() finished its work. The module may fine tune the function bounds 
  
@param possible_return_code: (int *), in/out
@param pfn: (func_t *)
@param max_func_end_ea: (::ea_t) (from the kernel's point of view)
@retval void: </pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a4e2998bb5bb313169f0ddf6745e4e233">processor_t</a>.</p>

</div>
</div>
<a id="a4df0e8ffd1f184cd847b19968fefd0b8" name="a4df0e8ffd1f184cd847b19968fefd0b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df0e8ffd1f184cd847b19968fefd0b8">&#9670;&#160;</a></span>ev_gen_asm_or_lst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_gen_asm_or_lst </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>starting</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'FILE *'</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_asm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'html_line_cb_t **'</td>          <td class="paramname"><span class="paramname"><em>outline</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback: generating asm or lst file. The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output 
  
@param starting: (bool) beginning listing generation
@param fp: (FILE *) output file
@param is_asm: (bool) true:assembler, false:listing
@param flags: (int) flags passed to gen_file()
@param outline: (html_line_cb_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines
@retval void: </pre> 
</div>
</div>
<a id="a1b7c0946cb2b8beb40e42b6f5a9dc98e" name="a1b7c0946cb2b8beb40e42b6f5a9dc98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7c0946cb2b8beb40e42b6f5a9dc98e">&#9670;&#160;</a></span>ev_gen_map_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_gen_map_file </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>nlines</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'FILE *'</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate map file. If not implemented the kernel itself will create the map file. 
  
@param nlines: (int *) number of lines in map file (-1 means write error)
@param fp: (FILE *) output file
@retval 0: not implemented
@retval 1: ok
@retval -1: write error</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#ae40ac176480029031d2df46c60664bc0">processor_t</a>.</p>

</div>
</div>
<a id="a9209689a03ade8e0713052326cad279c" name="a9209689a03ade8e0713052326cad279c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9209689a03ade8e0713052326cad279c">&#9670;&#160;</a></span>ev_gen_regvar_def()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_gen_regvar_def </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'regvar_t *'</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate register variable definition line. 
  
@param outctx: (outctx_t *)
@param v: (regvar_t *)
@retval &gt;0: ok, generated the definition text
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a2be9476ff2b1c5f14a5a39c9f39d3ff5">processor_t</a>.</p>

</div>
</div>
<a id="a1fe29614c17b1214aed1b7fc2270bf48" name="a1fe29614c17b1214aed1b7fc2270bf48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe29614c17b1214aed1b7fc2270bf48">&#9670;&#160;</a></span>ev_gen_src_file_lnnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_gen_src_file_lnnum </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'size_t'</td>          <td class="paramname"><span class="paramname"><em>lnnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback: generate analog of: 
#line  123



  
@param outctx: (outctx_t *) output context
@param file: (const char *) source file (may be nullptr)
@param lnnum: (size_t) line number
@retval 1: directive has been generated
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a4fafdc0a87a512c1122db8ccdfafcdf6">processor_t</a>.</p>

</div>
</div>
<a id="a51b1676aebc7365ffe86fff257a7b96a" name="a51b1676aebc7365ffe86fff257a7b96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b1676aebc7365ffe86fff257a7b96a">&#9670;&#160;</a></span>ev_gen_stkvar_def()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_gen_stkvar_def </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'udm_t'</td>          <td class="paramname"><span class="paramname"><em>stkvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        int</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'tid_t'</td>          <td class="paramname"><span class="paramname"><em>tid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate stack variable definition line Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte 
  
@param outctx: (outctx_t *)
@param stkvar: (const udm_t *)
@param v: (sval_t)
@param tid: (tid_t) stkvar TID
@retval 1: ok
@retval 0: not implemented</pre> 
</div>
</div>
<a id="ada73dbafe23d4b3253588a60e6c07979" name="ada73dbafe23d4b3253588a60e6c07979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada73dbafe23d4b3253588a60e6c07979">&#9670;&#160;</a></span>ev_get_abi_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_abi_info </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'comp_t'</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get all possible ABI names and optional extensions for given compiler abiname/option is a string entirely consisting of letters, digits and underscore 
  
@param comp: (comp_t) - compiler ID
@retval 0: not implemented
@retval 1: ok</pre> 
</div>
</div>
<a id="a14872926d65eafe7a620a509c32f6115" name="a14872926d65eafe7a620a509c32f6115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14872926d65eafe7a620a509c32f6115">&#9670;&#160;</a></span>ev_get_autocmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_get_autocmt </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Callback: get dynamic auto comment. Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. 'insn' contains valid info. 
  
@param insn: (const insn_t*) the instruction
@retval 1: new comment has been generated
@retval 0: callback has not been handled. the buffer must not be changed in this case</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a22834512e49ac848091a007b60969389">processor_t</a>.</p>

</div>
</div>
<a id="a6b8dbacb923c08223dbed0f28738dc30" name="a6b8dbacb923c08223dbed0f28738dc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8dbacb923c08223dbed0f28738dc30">&#9670;&#160;</a></span>ev_get_bg_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_bg_color </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'bgcolor_t *'</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get item background color. Plugins can hook this callback to color disassembly lines dynamically 
  
@param color: (bgcolor_t *), out
@param ea: (::ea_t)
@retval 0: not implemented
@retval 1: color set</pre> 
</div>
</div>
<a id="abf4370eeca31cee02516eb881a2c92c5" name="abf4370eeca31cee02516eb881a2c92c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4370eeca31cee02516eb881a2c92c5">&#9670;&#160;</a></span>ev_get_cc_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_cc_regs </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'callregs_t'</td>          <td class="paramname"><span class="paramname"><em>regs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'cm_t'</td>          <td class="paramname"><span class="paramname"><em>cc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get register allocation convention for given calling convention 
  
@param regs: (callregs_t *), out
@param cc: (cm_t)
@retval 1: 
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a3bf1821475d5cc282b58b648656d9f73" name="a3bf1821475d5cc282b58b648656d9f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf1821475d5cc282b58b648656d9f73">&#9670;&#160;</a></span>ev_get_code16_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_code16_mode </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get ISA 16-bit mode 
  
@param ea: (ea_t) address to get the ISA mode
@retval 1: 16-bit mode
@retval 0: not implemented or 32-bit mode</pre> 
</div>
</div>
<a id="a47c52029898f918e3f08a7d40975ac54" name="a47c52029898f918e3f08a7d40975ac54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c52029898f918e3f08a7d40975ac54">&#9670;&#160;</a></span>ev_get_dbr_opnum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_dbr_opnum </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>opnum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the number of the operand to be displayed in the debugger reference view (text mode). 
  
@param opnum: (int *) operand number (out, -1 means no such operand)
@param insn: (const insn_t*) the instruction
@retval 0: unimplemented
@retval 1: implemented</pre> 
</div>
</div>
<a id="ab949606f0c74f5509fc26a5840d3058b" name="ab949606f0c74f5509fc26a5840d3058b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab949606f0c74f5509fc26a5840d3058b">&#9670;&#160;</a></span>ev_get_default_enum_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_default_enum_size </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get default enum size. Not generated anymore. inf_get_cc_size_e() is used instead </pre> 
</div>
</div>
<a id="aee5b8cabe60d1e1136f00c66a6abe0ff" name="aee5b8cabe60d1e1136f00c66a6abe0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5b8cabe60d1e1136f00c66a6abe0ff">&#9670;&#160;</a></span>ev_get_frame_retsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_frame_retsize </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>frsize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_t const *'
        </td>          <td class="paramname"><span class="paramname"><em>pfn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get size of function return address in bytes If this event is not implemented, the kernel will assume
* 8 bytes for 64-bit function
* 4 bytes for 32-bit function
* 2 bytes otherwise



@param frsize: (int *) frame size (out)
@param pfn: (const func_t *), can't be nullptr
@retval 1: ok
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a0c8f79744644f996b3144924aa806fcb">processor_t</a>.</p>

</div>
</div>
<a id="a8429d28b83f0e6f464550ea64f4edac5" name="a8429d28b83f0e6f464550ea64f4edac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8429d28b83f0e6f464550ea64f4edac5">&#9670;&#160;</a></span>ev_get_macro_insn_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_macro_insn_head </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>head</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a>
        </td>          <td class="paramname"><span class="paramname"><em>ip</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the start of a macro instruction. This notification is called if IP points to the middle of an instruction 
  
@param head: (::ea_t *), out: answer, BADADDR means normal instruction
@param ip: (::ea_t) instruction address
@retval 0: unimplemented
@retval 1: implemented</pre> 
</div>
</div>
<a id="ae64f54a2a890f8612d5860c6de7e4b01" name="ae64f54a2a890f8612d5860c6de7e4b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64f54a2a890f8612d5860c6de7e4b01">&#9670;&#160;</a></span>ev_get_operand_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_get_operand_string </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
        </td>          <td class="paramname"><span class="paramname"><em>opnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Request text string for operand (cli, java, ...). 
  
@param insn: (const insn_t*) the instruction
@param opnum: (int) operand number, -1 means any string operand
@retval 0: no string (or empty string)
@retval &gt;0: original string length without terminating zero</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#afb5c8eda26875b2f9dd926a1c84c04b6">processor_t</a>.</p>

</div>
</div>
<a id="a3fa9a674c51c76cedee921f30309f5dc" name="a3fa9a674c51c76cedee921f30309f5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa9a674c51c76cedee921f30309f5dc">&#9670;&#160;</a></span>ev_get_procmod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_procmod </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get pointer to the processor module object. All processor modules must implement this. The pointer is returned as size_t. </pre> 
</div>
</div>
<a id="a7a4b690433e2825be5982cf86b6f48c1" name="a7a4b690433e2825be5982cf86b6f48c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4b690433e2825be5982cf86b6f48c1">&#9670;&#160;</a></span>ev_get_reg_accesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_reg_accesses </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'<a class="el" href="classida__idp_1_1reg__accesses__t.html">reg_accesses_t</a>'</td>          <td class="paramname"><span class="paramname"><em>accvec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get info about the registers that are used/changed by an instruction. 
  
@param accvec: (reg_accesses_t*) out: info about accessed registers
@param insn: (const insn_t *) instruction in question
@param flags: (int) reserved, must be 0
@retval -1: if accvec is nullptr
@retval 1: found the requested access (and filled accvec)
@retval 0: not implemented</pre> 
</div>
</div>
<a id="ab5969273acccc09c531c2565ad28dc7c" name="ab5969273acccc09c531c2565ad28dc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5969273acccc09c531c2565ad28dc7c">&#9670;&#160;</a></span>ev_get_reg_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_reg_info </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'char const **'</td>          <td class="paramname"><span class="paramname"><em>main_regname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'bitrange_t'</td>          <td class="paramname"><span class="paramname"><em>bitrange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>regname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get register information by its name. example: "ah" returns:
* main_regname="eax"
* bitrange_t = { offset==8, nbits==8 }


This callback may be unimplemented if the register names are all present in processor_t::reg_names and they all have the same size 
  
@param main_regname: (const char **), out
@param bitrange: (bitrange_t *), out: position and size of the value within 'main_regname' (empty bitrange == whole register)
@param regname: (const char *)
@retval 1: ok
@retval -1: failed (not found)
@retval 0: unimplemented</pre> 
</div>
</div>
<a id="a78e62f1f2ae524284ebecb8677810600" name="a78e62f1f2ae524284ebecb8677810600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e62f1f2ae524284ebecb8677810600">&#9670;&#160;</a></span>ev_get_reg_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_get_reg_name </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'size_t'</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int
        </td>          <td class="paramname"><span class="paramname"><em>reghi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate text representation of a register. Most processor modules do not need to implement this callback. It is useful only if processor_t::reg_names[reg] does not provide the correct register name. 
  
@param reg: (int) internal register number as defined in the processor module
@param width: (size_t) register width in bytes
@param reghi: (int) if not -1 then this function will return the register pair
@retval -1: if error
@retval strlen(buf): if success</pre> 
</div>
</div>
<a id="a4117e379d83b28c49baddf8c8fbfbea6" name="a4117e379d83b28c49baddf8c8fbfbea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4117e379d83b28c49baddf8c8fbfbea6">&#9670;&#160;</a></span>ev_get_simd_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_simd_types </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'simd_info_vec_t *'</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'simd_info_t'</td>          <td class="paramname"><span class="paramname"><em>simd_attrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'argloc_t'</td>          <td class="paramname"><span class="paramname"><em>argloc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>create_tifs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get SIMD-related types according to given attributes ant/or argument location 
  
@param out: (::simd_info_vec_t *)
@param simd_attrs: (const simd_info_t *), may be nullptr
@param argloc: (const argloc_t *), may be nullptr
@param create_tifs: (bool) return valid tinfo_t objects, create if neccessary
@retval number: of found types
@retval -1: error If name==nullptr, initialize all SIMD types</pre> 
</div>
</div>
<a id="a9fca6346b383ac7473a6302b36698d9d" name="a9fca6346b383ac7473a6302b36698d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fca6346b383ac7473a6302b36698d9d">&#9670;&#160;</a></span>ev_get_stkarg_area_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_stkarg_area_info </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'stkarg_area_info_t'</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'cm_t'
        </td>          <td class="paramname"><span class="paramname"><em>cc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get some metrics of the stack argument area. 
  
@param out: (stkarg_area_info_t *) ptr to stkarg_area_info_t
@param cc: (cm_t) calling convention
@retval 1: if success
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a5fe3abbf262d746a500e544ed3f36b7f" name="a5fe3abbf262d746a500e544ed3f36b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe3abbf262d746a500e544ed3f36b7f">&#9670;&#160;</a></span>ev_get_stkvar_scale_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_get_stkvar_scale_factor </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Should stack variable references be multiplied by a coefficient before being used in the stack frame?. Currently used by TMS320C55 because the references into the stack should be multiplied by 2 
  
@returns scaling factor
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a9c89b85b472c0b68f78f921bee625369" name="a9c89b85b472c0b68f78f921bee625369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c89b85b472c0b68f78f921bee625369">&#9670;&#160;</a></span>ev_getreg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_getreg </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uval_t *'</td>          <td class="paramname"><span class="paramname"><em>regval</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>regnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">IBM PC only internal request, should never be used for other purpose Get register value by internal index 
  
@param regval: (uval_t *), out
@param regnum: (int)
@retval 1: ok
@retval 0: not implemented
@retval -1: failed (undefined value or bad regnum)</pre> 
</div>
</div>
<a id="a47227cbc59e9c885bed003cbfa8ace5e" name="a47227cbc59e9c885bed003cbfa8ace5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47227cbc59e9c885bed003cbfa8ace5e">&#9670;&#160;</a></span>ev_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_init </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>idp_modname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The IDP module is just loaded. 
  
@param idp_modname: (const char *) processor module name
@retval &lt;0: on failure</pre> 
</div>
</div>
<a id="a8c2c97574380e1cb1ab46144cc3c729a" name="a8c2c97574380e1cb1ab46144cc3c729a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2c97574380e1cb1ab46144cc3c729a">&#9670;&#160;</a></span>ev_insn_reads_tbit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_insn_reads_tbit </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'processor_t.regval_getter_t *'</td>          <td class="paramname"><span class="paramname"><em>getreg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'regval_t'</td>          <td class="paramname"><span class="paramname"><em>regvalues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if insn will read the TF bit. 
  
@param insn: (const insn_t*) the instruction
@param getreg: (::processor_t::regval_getter_t *) function to get register values
@param regvalues: (const regval_t *) register values array
@retval 2: yes, will generate 'step' exception
@retval 1: yes, will store the TF bit in memory
@retval 0: no</pre> 
</div>
</div>
<a id="a7de828bd6e18cc30b54ee5feb2f4a8f5" name="a7de828bd6e18cc30b54ee5feb2f4a8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de828bd6e18cc30b54ee5feb2f4a8f5">&#9670;&#160;</a></span>ev_is_align_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_align_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is the instruction created only for alignment purposes?. Do not directly call this function, use is_align_insn() 
  
@param ea: (ea_t) - instruction address
@retval number: of bytes in the instruction</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a549618f5de442365fda02cbf2f432a10">processor_t</a>.</p>

</div>
</div>
<a id="ac519cea11061dc53efd1c59d0de960f9" name="ac519cea11061dc53efd1c59d0de960f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac519cea11061dc53efd1c59d0de960f9">&#9670;&#160;</a></span>ev_is_alloca_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_alloca_probe </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Does the function at 'ea' behave as __alloca_probe? 
  
@param ea: (::ea_t)
@retval 1: yes
@retval 0: no</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a7078f46016d14615832e4cf64b1a0364">processor_t</a>.</p>

</div>
</div>
<a id="ab38e95e856805057446222cc1a0af07c" name="ab38e95e856805057446222cc1a0af07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38e95e856805057446222cc1a0af07c">&#9670;&#160;</a></span>ev_is_basic_block_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_basic_block_end </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>call_insn_stops_block</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is the current instruction end of a basic block?. This function should be defined for processors with delayed jump slots. 
  
@param insn: (const insn_t*) the instruction
@param call_insn_stops_block: (bool)
@retval 0: unknown
@retval &lt;0: no
@retval 1: yes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a247742f6993f185c7c59a5c876fb56bf">processor_t</a>.</p>

</div>
</div>
<a id="a6385f931ec2bd391d1194eb87ebcb336" name="a6385f931ec2bd391d1194eb87ebcb336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6385f931ec2bd391d1194eb87ebcb336">&#9670;&#160;</a></span>ev_is_call_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_call_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is the instruction a "call"? 
  
@param insn: (const insn_t *) instruction
@retval 0: unknown
@retval &lt;0: no
@retval 1: yes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#af56e422d5389f7142ee3626492e346e0">processor_t</a>.</p>

</div>
</div>
<a id="aeadf5a2249b6f5ba7fc101103f7c9d83" name="aeadf5a2249b6f5ba7fc101103f7c9d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadf5a2249b6f5ba7fc101103f7c9d83">&#9670;&#160;</a></span>ev_is_cond_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_cond_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is conditional instruction? 
  
@param insn: (const insn_t *) instruction address
@retval 1: yes
@retval -1: no
@retval 0: not implemented or not instruction</pre> 
</div>
</div>
<a id="a4badb24b6e181f593a888805a374dcb4" name="a4badb24b6e181f593a888805a374dcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4badb24b6e181f593a888805a374dcb4">&#9670;&#160;</a></span>ev_is_control_flow_guard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_control_flow_guard </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>p_reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'
        </td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Detect if an instruction is a "thunk call" to a flow guard function (equivalent to call reg/return/nop) 
  
@param p_reg: (int *) indirect register number, may be -1
@param insn: (const insn_t *) call/jump instruction
@retval -1: no thunk detected
@retval 1: indirect call
@retval 2: security check routine call (NOP)
@retval 3: return thunk
@retval 0: not implemented</pre> 
</div>
</div>
<a id="af6cb5f82cf45213012f7de69ac5f6b3a" name="af6cb5f82cf45213012f7de69ac5f6b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cb5f82cf45213012f7de69ac5f6b3a">&#9670;&#160;</a></span>ev_is_far_jump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_far_jump </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>icode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">is indirect far jump or call instruction? meaningful only if the processor has 'near' and 'far' reference types 
  
@param icode: (int)
@retval 0: not implemented
@retval 1: yes
@retval -1: no</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a27ff33ba96c12688f726af389c4e3cee">processor_t</a>.</p>

</div>
</div>
<a id="ae501f3f7ad278589c6219b3106f28e2f" name="ae501f3f7ad278589c6219b3106f28e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae501f3f7ad278589c6219b3106f28e2f">&#9670;&#160;</a></span>ev_is_indirect_jump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_indirect_jump </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine if instruction is an indirect jump. If CF_JUMP bit cannot describe all jump types jumps, please define this callback. 
  
@param insn: (const insn_t*) the instruction
@retval 0: use CF_JUMP
@retval 1: no
@retval 2: yes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#af334e9457662d0419873e5ef19f03b6d">processor_t</a>.</p>

</div>
</div>
<a id="a1d147a1a3a942c1688c4de42509173d7" name="a1d147a1a3a942c1688c4de42509173d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d147a1a3a942c1688c4de42509173d7">&#9670;&#160;</a></span>ev_is_insn_table_jump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_insn_table_jump </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reserved.
</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a2d377562170da4c6ab17fa5fb5acbb7c">processor_t</a>.</p>

</div>
</div>
<a id="aa9cc4b5d0f454f45540cd5635301850c" name="aa9cc4b5d0f454f45540cd5635301850c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9cc4b5d0f454f45540cd5635301850c">&#9670;&#160;</a></span>ev_is_jump_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_jump_func </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_t *'</td>          <td class="paramname"><span class="paramname"><em>pfn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>jump_target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>func_pointer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is the function a trivial "jump" function?. 
  
@param pfn: (func_t *)
@param jump_target: (::ea_t *)
@param func_pointer: (::ea_t *)
@retval &lt;0: no
@retval 0: don't know
@retval 1: yes, see 'jump_target' and 'func_pointer'</pre> 
</div>
</div>
<a id="adb6682c9c3fca400e02882f3d7cb8260" name="adb6682c9c3fca400e02882f3d7cb8260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6682c9c3fca400e02882f3d7cb8260">&#9670;&#160;</a></span>ev_is_ret_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_ret_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uchar'</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is the instruction a "return"? 
  
@param insn: (const insn_t *) instruction
@param flags: (uchar), combination of IRI_... flags (see above)
@retval 0: unknown
@retval &lt;0: no
@retval 1: yes</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a5c7d02a8f6a1e196d318dffe58555f38">processor_t</a>.</p>

</div>
</div>
<a id="a677260b53a80ece52243a1874af4ca73" name="a677260b53a80ece52243a1874af4ca73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677260b53a80ece52243a1874af4ca73">&#9670;&#160;</a></span>ev_is_sane_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_sane_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>no_crefs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Is the instruction sane for the current file type?. 
  
@param insn: (const insn_t*) the instruction
@param no_crefs: (int) 1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction) 0: the instruction is created because of some coderef, user request or another weighty reason.
@retval &gt;=0: ok
@retval &lt;0: no, the instruction isn't likely to appear in the program</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a249c2ea192fc90fbb2fc0b9a2f53b0f7">processor_t</a>.</p>

</div>
</div>
<a id="a4b7b42e359913087e27fa23a847c4c7a" name="a4b7b42e359913087e27fa23a847c4c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7b42e359913087e27fa23a847c4c7a">&#9670;&#160;</a></span>ev_is_sp_based()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_sp_based </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int *'</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'op_t const *'</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether the operand is relative to stack pointer or frame pointer This event is used to determine how to output a stack variable If not implemented, then all operands are sp based by default. Implement this event only if some stack references use frame pointer instead of stack pointer. 
  
@param mode: (int *) out, combination of SP/FP operand flags
@param insn: (const insn_t *)
@param op: (const op_t *)
@retval 0: not implemented
@retval 1: ok</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#acecde5b8986e6d2984e2e8efbbeb7050">processor_t</a>.</p>

</div>
</div>
<a id="a33067a0e77f5c0304c444199852826b9" name="a33067a0e77f5c0304c444199852826b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33067a0e77f5c0304c444199852826b9">&#9670;&#160;</a></span>ev_is_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_is_switch </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'switch_info_t'</td>          <td class="paramname"><span class="paramname"><em>si</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find 'switch' idiom or override processor module's decision. It will be called for instructions marked with CF_JUMP. 
  
@param si: (switch_info_t *), out
@param insn: (const insn_t *) instruction possibly belonging to a switch
@retval 1: switch is found, 'si' is filled. IDA will create the switch using the filled 'si'
@retval -1: no switch found. This value forbids switch creation by the processor module
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a9f2db83fe364ee49a53134046d450c43">processor_t</a>.</p>

</div>
</div>
<a id="afca7dd82b8f8a0d7c1c35f9629a73857" name="afca7dd82b8f8a0d7c1c35f9629a73857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7dd82b8f8a0d7c1c35f9629a73857">&#9670;&#160;</a></span>ev_last_cb_before_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_last_cb_before_loader </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2f8168609705f3db1855510c8fe6ae3" name="ae2f8168609705f3db1855510c8fe6ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f8168609705f3db1855510c8fe6ae3">&#9670;&#160;</a></span>ev_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_loader </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This code and higher ones are reserved for the loaders. The arguments and the return values are defined by the loaders </pre> 
</div>
</div>
<a id="aabd4747537c6b1bfc6aae3d0510a4463" name="aabd4747537c6b1bfc6aae3d0510a4463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd4747537c6b1bfc6aae3d0510a4463">&#9670;&#160;</a></span>ev_lower_func_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_lower_func_type </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'intvec_t *'</td>          <td class="paramname"><span class="paramname"><em>argnums</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_type_data_t'
        </td>          <td class="paramname"><span class="paramname"><em>fti</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get function arguments which should be converted to pointers when lowering function prototype. The processor module can also modify 'fti' in order to make non-standard conversion of some arguments. 
  
@param argnums: (intvec_t *), out - numbers of arguments to be converted to pointers in acsending order
@param fti: (func_type_data_t *), inout func type details
@retval 0: not implemented
@retval 1: argnums was filled
@retval 2: argnums was filled and made substantial changes to fti argnums[0] can contain a special negative value indicating that the return value should be passed as a hidden 'retstr' argument: -1 this argument is passed as the first one and the function returns a pointer to the argument, -2 this argument is passed as the last one and the function returns a pointer to the argument, -3 this argument is passed as the first one and the function returns 'void'.</pre> 
</div>
</div>
<a id="a9e78b1df2a11a06f0e86f9b73f65940a" name="a9e78b1df2a11a06f0e86f9b73f65940a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78b1df2a11a06f0e86f9b73f65940a">&#9670;&#160;</a></span>ev_max_ptr_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_max_ptr_size </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get maximal size of a pointer in bytes. 
  
@returns max possible size of a pointer</pre> 
</div>
</div>
<a id="a3d4665d83a54b5743a7e11a4f2eee8af" name="a3d4665d83a54b5743a7e11a4f2eee8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4665d83a54b5743a7e11a4f2eee8af">&#9670;&#160;</a></span>ev_may_be_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_may_be_func </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'insn_t const *'</td>          <td class="paramname"><span class="paramname"><em>insn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Can a function start here? 
  
@param insn: (const insn_t*) the instruction
@param state: (int) autoanalysis phase 0: creating functions 1: creating chunks
@returns probability 1..100</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a6d03495764a252e6abb0302e61079abd">processor_t</a>.</p>

</div>
</div>
<a id="a6c246e62234bf406e30fa2f508aefc35" name="a6c246e62234bf406e30fa2f508aefc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c246e62234bf406e30fa2f508aefc35">&#9670;&#160;</a></span>ev_may_show_sreg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_may_show_sreg </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>current_ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kernel wants to display the segment registers in the messages window. 
  
@param current_ea: (::ea_t)
@retval &lt;0: if the kernel should not show the segment registers. (assuming that the module has done it)
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a7458dade04d101af038dfb66eda8d859">processor_t</a>.</p>

</div>
</div>
<a id="add862e5422ccfad4fb703c48893405a4" name="add862e5422ccfad4fb703c48893405a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add862e5422ccfad4fb703c48893405a4">&#9670;&#160;</a></span>ev_moving_segm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_moving_segm </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'segment_t *'</td>          <td class="paramname"><span class="paramname"><em>seg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">May the kernel move the segment? 
  
@param seg: (segment_t *) segment to move
@param to: (::ea_t) new segment start address
@param flags: (int) combination of Move segment flags
@retval 0: yes
@retval &lt;0: the kernel should stop</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a5398c9b9ac9bbfa09a22ec3efb30c84c">processor_t</a>.</p>

</div>
</div>
<a id="a6c6175fecda1abe143895fdebdc88312" name="a6c6175fecda1abe143895fdebdc88312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6175fecda1abe143895fdebdc88312">&#9670;&#160;</a></span>ev_newasm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_newasm </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>asmnum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Before setting a new assembler. 
  
@param asmnum: (int) See also ev_asm_installed</pre> 
</div>
</div>
<a id="a8528da1088f39b716318af4ebfba05c3" name="a8528da1088f39b716318af4ebfba05c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8528da1088f39b716318af4ebfba05c3">&#9670;&#160;</a></span>ev_newbinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_newbinary </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'char *'</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'qoff64_t'</td>          <td class="paramname"><span class="paramname"><em>fileoff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>basepara</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>binoff</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uint64'
        </td>          <td class="paramname"><span class="paramname"><em>nbytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">IDA is about to load a binary file. 
  
@param filename: (char *) binary file name
@param fileoff: (qoff64_t) offset in the file
@param basepara: (::ea_t) base loading paragraph
@param binoff: (::ea_t) loader offset
@param nbytes: (::uint64) number of bytes to load</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a12a895cf75c31d37e8f49ae040604955">processor_t</a>.</p>

</div>
</div>
<a id="a2e0f51af8ee71de92a728cf39c911da0" name="a2e0f51af8ee71de92a728cf39c911da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0f51af8ee71de92a728cf39c911da0">&#9670;&#160;</a></span>ev_newfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_newfile </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'char *'</td>          <td class="paramname"><span class="paramname"><em>fname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A new file has been loaded. 
  
@param fname: (char *) input file name</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1__notify__when__dispatcher__t_1_1___i_d_p___hooks.html#a7ffb52def8908a21719a49cbc300fbc6">_notify_when_dispatcher_t._IDP_Hooks</a>, and <a class="el" href="classida__idp_1_1processor__t.html#ae707e68948e747da3ee4557ee0ac8a13">processor_t</a>.</p>

</div>
</div>
<a id="abd6c1b470e80c866bf5c520132d8faf9" name="abd6c1b470e80c866bf5c520132d8faf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6c1b470e80c866bf5c520132d8faf9">&#9670;&#160;</a></span>ev_newprc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_newprc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pnum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keep_cfg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Before changing processor type. 
  
@param pnum: (int) processor number in the array of processor names
@param keep_cfg: (bool) true: do not modify kernel configuration
@retval 1: ok
@retval &lt;0: prohibit</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a5b1e13c1d21990828c6b16470ee792ac">processor_t</a>.</p>

</div>
</div>
<a id="a2b9475b3c89731aa5055306fb1c9672c" name="a2b9475b3c89731aa5055306fb1c9672c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9475b3c89731aa5055306fb1c9672c">&#9670;&#160;</a></span>ev_next_exec_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_next_exec_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ea_t *'</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        int</td>          <td class="paramname"><span class="paramname"><em>tid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'processor_t.regval_getter_t *'</td>          <td class="paramname"><span class="paramname"><em>getreg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'regval_t'
        </td>          <td class="paramname"><span class="paramname"><em>regvalues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get next address to be executed This function must return the next address to be executed. If the instruction following the current one is executed, then it must return BADADDR Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. 
  
@param target: (::ea_t *), out: pointer to the answer
@param ea: (::ea_t) instruction address
@param tid: (int) current therad id
@param getreg: (::processor_t::regval_getter_t *) function to get register values
@param regvalues: (const regval_t *) register values array
@retval 0: unimplemented
@retval 1: implemented</pre> 
</div>
</div>
<a id="ad139f674fbaec805ccbd858976c7ba7d" name="ad139f674fbaec805ccbd858976c7ba7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad139f674fbaec805ccbd858976c7ba7d">&#9670;&#160;</a></span>ev_oldfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_oldfile </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'char *'</td>          <td class="paramname"><span class="paramname"><em>fname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An old file has been loaded. 
  
@param fname: (char *) input file name</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1__notify__when__dispatcher__t_1_1___i_d_p___hooks.html#a510f1fac3a5ccd77111e7c8c18a4b16f">_notify_when_dispatcher_t._IDP_Hooks</a>, and <a class="el" href="classida__idp_1_1processor__t.html#a669ac989602686d35ab6288bc44b7a1a">processor_t</a>.</p>

</div>
</div>
<a id="a9e3d8235a680d8d37eabe96ae72a5c0e" name="a9e3d8235a680d8d37eabe96ae72a5c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3d8235a680d8d37eabe96ae72a5c0e">&#9670;&#160;</a></span>ev_out_assumes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_assumes </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to produce assume directives when segment register value changes. 
  
@param outctx: (outctx_t *)
@retval 1: ok
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a95138b992eba3426076fc66ecfb50db5">processor_t</a>.</p>

</div>
</div>
<a id="aaef6821c579c6023fa3b46a916b9dc5c" name="aaef6821c579c6023fa3b46a916b9dc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef6821c579c6023fa3b46a916b9dc5c">&#9670;&#160;</a></span>ev_out_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_data </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>analyze_only</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate text representation of data items This function may change the database and create cross-references if analyze_only is set 
  
@param outctx: (outctx_t *)
@param analyze_only: (bool)
@retval 1: ok
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a0d0a59b609e1fa84ec7d53ba91c75f46">processor_t</a>.</p>

</div>
</div>
<a id="a337c1fa66b36b2bb828d0bab2dda2faf" name="a337c1fa66b36b2bb828d0bab2dda2faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337c1fa66b36b2bb828d0bab2dda2faf">&#9670;&#160;</a></span>ev_out_footer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_footer </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to produce end of disassembled text 
  
@param outctx: (outctx_t *)
@retval void: </pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a36c0b11babe05755e85de2b4be767a23">processor_t</a>.</p>

</div>
</div>
<a id="a437e405d5d8a5ca7246da22e02a22a11" name="a437e405d5d8a5ca7246da22e02a22a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437e405d5d8a5ca7246da22e02a22a11">&#9670;&#160;</a></span>ev_out_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_header </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to produce start of disassembled text 
  
@param outctx: (outctx_t *)
@retval void: </pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a44adcb23e0ed1fa2a10a44f7a01858a0">processor_t</a>.</p>

</div>
</div>
<a id="a8e89c6e9d63dbb1e02e49ed10d838f42" name="a8e89c6e9d63dbb1e02e49ed10d838f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e89c6e9d63dbb1e02e49ed10d838f42">&#9670;&#160;</a></span>ev_out_insn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev_out_insn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate text representation of an instruction in 'ctx.insn' outctx_t provides functions to output the generated text. This function shouldn't change the database, flags or anything else. All these actions should be performed only by emu_insn() function. 
  
@param outctx: (outctx_t *)
@retval void: </pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a36d8942027a2b1ab2544a42224fd3c4d">processor_t</a>.</p>

</div>
</div>
<a id="a13078da2cb11548de8c320fac31a50f8" name="a13078da2cb11548de8c320fac31a50f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13078da2cb11548de8c320fac31a50f8">&#9670;&#160;</a></span>ev_out_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_label </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>colored_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kernel is going to generate an instruction label line or a function header. 
  
@param outctx: (outctx_t *)
@param colored_name: (const char *)
@retval &lt;0: if the kernel should not generate the label
@retval 0: not implemented or continue</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#acdf107cc082c8397d3bd35eb69451451">processor_t</a>.</p>

</div>
</div>
<a id="a31c8279611dda562f25eaf1596718df4" name="a31c8279611dda562f25eaf1596718df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c8279611dda562f25eaf1596718df4">&#9670;&#160;</a></span>ev_out_mnem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_mnem </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate instruction mnemonics. This callback should append the colored mnemonics to ctx.outbuf Optional notification, if absent, out_mnem will be called. 
  
@param outctx: (outctx_t *)
@retval 1: if appended the mnemonics
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a98cf3347894b1a0d179e1b6d4a1cd40a">processor_t</a>.</p>

</div>
</div>
<a id="a3550e39c504f52bd2e8a8c92892b03ec" name="a3550e39c504f52bd2e8a8c92892b03ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3550e39c504f52bd2e8a8c92892b03ec">&#9670;&#160;</a></span>ev_out_operand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ev_out_operand </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'op_t const *'</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate text representation of an instruction operand outctx_t provides functions to output the generated text. All these actions should be performed only by emu_insn() function. 
  
@param outctx: (outctx_t *)
@param op: (const op_t *)
@retval 1: ok
@retval -1: operand is hidden</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a31dc8535e2b09b9f7e4bfe76a87b1b71">processor_t</a>.</p>

</div>
</div>
<a id="a08d0369271682dc4d2ec0adafde8b0c2" name="a08d0369271682dc4d2ec0adafde8b0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d0369271682dc4d2ec0adafde8b0c2">&#9670;&#160;</a></span>ev_out_segend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_segend </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'segment_t *'</td>          <td class="paramname"><span class="paramname"><em>seg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to produce end of segment 
  
@param outctx: (outctx_t *)
@param seg: (segment_t *)
@retval 1: ok
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a405665ee2b0edbab209a0f21e165aa36">processor_t</a>.</p>

</div>
</div>
<a id="acc0a3708b48a890307e39e6adb4ef2ec" name="acc0a3708b48a890307e39e6adb4ef2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0a3708b48a890307e39e6adb4ef2ec">&#9670;&#160;</a></span>ev_out_segstart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_segstart </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'segment_t *'</td>          <td class="paramname"><span class="paramname"><em>seg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function to produce start of segment 
  
@param outctx: (outctx_t *)
@param seg: (segment_t *)
@retval 1: ok
@retval 0: not implemented</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a3a59fb63cec3b131067c3a252be6ef03">processor_t</a>.</p>

</div>
</div>
<a id="a64ad1a0f7645b3db9a8521c85538977c" name="a64ad1a0f7645b3db9a8521c85538977c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ad1a0f7645b3db9a8521c85538977c">&#9670;&#160;</a></span>ev_out_special_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_out_special_item </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'outctx_t *'</td>          <td class="paramname"><span class="paramname"><em>outctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uchar'
        </td>          <td class="paramname"><span class="paramname"><em>segtype</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate text representation of an item in a special segment i.e. absolute symbols, externs, communal definitions etc 
  
@param outctx: (outctx_t *)
@param segtype: (uchar)
@retval 1: ok
@retval 0: not implemented
@retval -1: overflow</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#af6e5b48239299ffe25bcd181642b047a">processor_t</a>.</p>

</div>
</div>
<a id="a75ab19d863e8cb13341b151412b1de15" name="a75ab19d863e8cb13341b151412b1de15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ab19d863e8cb13341b151412b1de15">&#9670;&#160;</a></span>ev_privrange_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_privrange_changed </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'range_t'</td>          <td class="paramname"><span class="paramname"><em>old_privrange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'adiff_t'
        </td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Privrange interval has been moved to a new location. Most common actions to be done by module in this case: fix indices of netnodes used by module 
  
@param old_privrange: (const range_t *) - old privrange interval
@param delta: (::adiff_t)
@retval 0: Ok
@retval -1: error (and message in errbuf)</pre> 
</div>
</div>
<a id="a09b0a5572712973c86475579e319d655" name="a09b0a5572712973c86475579e319d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b0a5572712973c86475579e319d655">&#9670;&#160;</a></span>ev_realcvt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_realcvt </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'void *'</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'fpvalue_t *'</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uint16'</td>          <td class="paramname"><span class="paramname"><em>swt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Floating point -&gt; IEEE conversion 
  
@param m: (void *) ptr to processor-specific floating point value
@param e: (fpvalue_t *) IDA representation of a floating point value
@param swt: (uint16) operation (see realcvt() in ieee.h)
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a26541b58a3abe06aedfb41cdcb1de961" name="a26541b58a3abe06aedfb41cdcb1de961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26541b58a3abe06aedfb41cdcb1de961">&#9670;&#160;</a></span>ev_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_rename </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>new_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kernel is going to rename a byte. 
  
@param ea: (::ea_t)
@param new_name: (const char *)
@retval &lt;0: if the kernel should not rename it.
@retval 2: to inhibit the notification. I.e., the kernel should not rename, but 'set_name()' should return 'true'. also see renamed the return value is ignored when kernel is going to delete name</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#af6cd541a9b952d15a760aafbcf7c7515">processor_t</a>.</p>

</div>
</div>
<a id="a58a721c0bd85c93e04f5f9add45377f7" name="a58a721c0bd85c93e04f5f9add45377f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a721c0bd85c93e04f5f9add45377f7">&#9670;&#160;</a></span>ev_replaying_undo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_replaying_undo </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>action_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'undo_records_t const *'</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_undo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replaying an undo/redo buffer 
  
@param action_name: (const char *) action that we perform undo/redo for. may be nullptr for intermediary buffers.
@param vec: (const undo_records_t *)
@param is_undo: (bool) true if performing undo, false if performing redo This event may be generated multiple times per undo/redo</pre> 
</div>
</div>
<a id="ae67bc624c4e71be2d6ce07fc771a58a9" name="ae67bc624c4e71be2d6ce07fc771a58a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67bc624c4e71be2d6ce07fc771a58a9">&#9670;&#160;</a></span>ev_set_code16_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_set_code16_mode </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>code16</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Some processors have ISA 16-bit mode e.g. ARM Thumb mode, PPC VLE, MIPS16 Set ISA 16-bit mode 
  
@param ea: (ea_t) address to set new ISA mode
@param code16: (bool) true for 16-bit mode, false for 32-bit mode</pre> 
</div>
</div>
<a id="a02e02f3df91bf3186b718577215424a1" name="a02e02f3df91bf3186b718577215424a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e02f3df91bf3186b718577215424a1">&#9670;&#160;</a></span>ev_set_idp_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_set_idp_options </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>keyword</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'void const *'</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>idb_loaded</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set IDP-specific configuration option Also see set_options_t in config.hpp 
  
@param keyword: (const char *)
@param value_type: (int)
@param value: (const void *)
@param idb_loaded: (bool) true if the ev_oldfile/ev_newfile events have been generated
@retval 1: ok
@retval 0: not implemented
@retval -1: error (and message in errbuf)</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#aa0ca36af29098baaf114b3c00bb7fb08">processor_t</a>.</p>

</div>
</div>
<a id="a611d2aac99e9868c2b4a41e8fb41e392" name="a611d2aac99e9868c2b4a41e8fb41e392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611d2aac99e9868c2b4a41e8fb41e392">&#9670;&#160;</a></span>ev_set_proc_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_set_proc_options </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>confidence</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Called if the user specified an option string in the command line: -p&lt;processor name&gt;:&lt;options&gt;. Can be used for setting a processor subtype. Also called if option string is passed to set_processor_type() and IDC's SetProcessorType(). 
  
@param options: (const char *)
@param confidence: (int) 0: loader's suggestion 1: user's decision
@retval &lt;0: if bad option string</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#afc0f19441c6ae34cc9d6e9d63a043c65">processor_t</a>.</p>

</div>
</div>
<a id="a2bf80ba458c80353c7250ac1821ab84d" name="a2bf80ba458c80353c7250ac1821ab84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf80ba458c80353c7250ac1821ab84d">&#9670;&#160;</a></span>ev_setup_til()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_setup_til </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Setup default type libraries. (called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. 
  
@retval void: </pre> 
</div>
</div>
<a id="a9a42c721b8941dcaa2da92cdf7711fc6" name="a9a42c721b8941dcaa2da92cdf7711fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a42c721b8941dcaa2da92cdf7711fc6">&#9670;&#160;</a></span>ev_str2reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_str2reg </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>regname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a register name to a register number. The register number is the register index in the processor_t::reg_names array Most processor modules do not need to implement this callback It is useful only if processor_t::reg_names[reg] does not provide the correct register names 
  
@param regname: (const char *)
@retval register: number + 1
@retval 0: not implemented or could not be decoded</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a1096031d7dfc9bad00ca884088253b94">processor_t</a>.</p>

</div>
</div>
<a id="a319b1ed8394d61d93bd98153eae51c2b" name="a319b1ed8394d61d93bd98153eae51c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319b1ed8394d61d93bd98153eae51c2b">&#9670;&#160;</a></span>ev_term()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_term </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The IDP module is being unloaded.
</pre> 
</div>
</div>
<a id="a2286312b285d2c941f781ae91dca1d87" name="a2286312b285d2c941f781ae91dca1d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2286312b285d2c941f781ae91dca1d87">&#9670;&#160;</a></span>ev_treat_hindering_item()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_treat_hindering_item </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>hindering_item_ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'flags64_t'</td>          <td class="paramname"><span class="paramname"><em>new_item_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>new_item_ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'asize_t'</td>          <td class="paramname"><span class="paramname"><em>new_item_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An item hinders creation of another item. 
  
@param hindering_item_ea: (::ea_t)
@param new_item_flags: (flags64_t) (0 for code)
@param new_item_ea: (::ea_t)
@param new_item_length: (::asize_t)
@retval 0: no reaction
@retval !=0: the kernel may delete the hindering item</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#ac80c666f70f73c9f297bfeecdec25a50">processor_t</a>.</p>

</div>
</div>
<a id="a320daefd98dfac488bfbc6edfcdd0033" name="a320daefd98dfac488bfbc6edfcdd0033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320daefd98dfac488bfbc6edfcdd0033">&#9670;&#160;</a></span>ev_undefine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_undefine </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An item in the database (insn or data) is being deleted. 
  
@param ea: (ea_t)
@retval 1: do not delete srranges at the item end
@retval 0: srranges can be deleted</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#afab8644196afed9c2c790e16f89f8187">processor_t</a>.</p>

</div>
</div>
<a id="a7e39f1fa75fcdde17e4c107e2e322fe8" name="a7e39f1fa75fcdde17e4c107e2e322fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e39f1fa75fcdde17e4c107e2e322fe8">&#9670;&#160;</a></span>ev_update_call_stack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_update_call_stack </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'call_stack_t'</td>          <td class="paramname"><span class="paramname"><em>stack</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'processor_t.regval_getter_t *'</td>          <td class="paramname"><span class="paramname"><em>getreg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'regval_t'</td>          <td class="paramname"><span class="paramname"><em>regvalues</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the call stack trace for the given thread. This callback is invoked when the process is suspended and should fill the 'trace' object with the information about the current call stack. Note that this callback is NOT invoked if the current debugger backend implements stack tracing via debugger_t::event_t::ev_update_call_stack. The debugger-specific algorithm takes priority. Implementing this callback in the processor module is useful when multiple debugging platforms follow similar patterns, and thus the same processor-specific algorithm can be used for different platforms. 
  
@param stack: (call_stack_t *) result
@param tid: (int) thread id
@param getreg: (::processor_t::regval_getter_t *) function to get register values
@param regvalues: (const regval_t *) register values array
@retval 1: ok
@retval -1: failed
@retval 0: unimplemented</pre> 
</div>
</div>
<a id="ab86016b6db5b48878221663def1d9e8c" name="ab86016b6db5b48878221663def1d9e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86016b6db5b48878221663def1d9e8c">&#9670;&#160;</a></span>ev_use_arg_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_use_arg_types </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_type_data_t'</td>          <td class="paramname"><span class="paramname"><em>fti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'funcargvec_t *'</td>          <td class="paramname"><span class="paramname"><em>rargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use information about callee arguments. 
  
@param ea: (::ea_t) address of the call instruction
@param fti: (func_type_data_t *) info about function type
@param rargs: (funcargvec_t *) array of register arguments
@retval 1: (and removes handled arguments from fti and rargs)
@retval 0: not implemented</pre> 
</div>
</div>
<a id="a750ebe872882db7319bf885bc0007555" name="a750ebe872882db7319bf885bc0007555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750ebe872882db7319bf885bc0007555">&#9670;&#160;</a></span>ev_use_regarg_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">'PyObject *' ev_use_regarg_type </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">
        'funcargvec_t const *'</td>          <td class="paramname"><span class="paramname"><em>rargs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use information about register argument. 
  
@param ea: (::ea_t) address of the instruction
@param rargs: (const funcargvec_t *) vector of register arguments (including regs extracted from scattered arguments)
@retval 1: 
@retval 0: not implemented</pre> 
</div>
</div>
<a id="adcaa77d23a1743ce9849a45b14d0e689" name="adcaa77d23a1743ce9849a45b14d0e689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaa77d23a1743ce9849a45b14d0e689">&#9670;&#160;</a></span>ev_use_stkarg_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_use_stkarg_type </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'funcarg_t'</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use information about a stack argument. 
  
@param ea: (::ea_t) address of the push instruction which pushes the function argument into the stack
@param arg: (const funcarg_t *) argument info
@retval 1: ok
@retval &lt;=0: failed, the kernel will create a comment with the argument name or type for the instruction</pre> 
</div>
</div>
<a id="ac8a35c8903bce0bd03548d21275687dc" name="ac8a35c8903bce0bd03548d21275687dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a35c8903bce0bd03548d21275687dc">&#9670;&#160;</a></span>ev_validate_flirt_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_validate_flirt_func </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceida__idaapi.html#a7b0aeaed04e477c02cf8ea3452002d1a">ida_idaapi.ea_t</a></td>          <td class="paramname"><span class="paramname"><em>start_ea</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str
        </td>          <td class="paramname"><span class="paramname"><em>funcname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flirt has recognized a library function. This callback can be used by a plugin or proc module to intercept it and validate such a function. 
  
@param start_ea: (::ea_t)
@param funcname: (const char *)
@retval -1: do not create a function,
@retval 0: function is validated</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#aa46e115fffec80d7075ea5daed3dbdb8">processor_t</a>.</p>

</div>
</div>
<a id="ae5dc9a44cc538494675b786cdc1000cf" name="ae5dc9a44cc538494675b786cdc1000cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5dc9a44cc538494675b786cdc1000cf">&#9670;&#160;</a></span>ev_verify_noreturn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_verify_noreturn </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_t *'</td>          <td class="paramname"><span class="paramname"><em>pfn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The kernel wants to set 'noreturn' flags for a function. 
  
@param pfn: (func_t *)
@retval 0: ok. any other value: do not set 'noreturn' flag</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a0c68b629d87c0c40e380e4f67261d4af">processor_t</a>.</p>

</div>
</div>
<a id="a42b56925353ba57232ea93f5fa1ec344" name="a42b56925353ba57232ea93f5fa1ec344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b56925353ba57232ea93f5fa1ec344">&#9670;&#160;</a></span>ev_verify_sp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ev_verify_sp </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'func_t *'</td>          <td class="paramname"><span class="paramname"><em>pfn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">All function instructions have been analyzed. Now the processor module can analyze the stack pointer for the whole function 
  
@param pfn: (func_t *)
@retval 0: ok
@retval &lt;0: bad stack pointer</pre> 
<p>Reimplemented in <a class="el" href="classida__idp_1_1processor__t.html#a5dc0b2e709fe70a7094cdffa55956966">processor_t</a>.</p>

</div>
</div>
<a id="a75fc95a1ce9ec3113384503d194c8802" name="a75fc95a1ce9ec3113384503d194c8802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75fc95a1ce9ec3113384503d194c8802">&#9670;&#160;</a></span>hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hook </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b323a538408e166ac784fb69d4b2938" name="a0b323a538408e166ac784fb69d4b2938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b323a538408e166ac784fb69d4b2938">&#9670;&#160;</a></span>unhook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool unhook </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a50e9fbdd6a13e9e50cfba34656086bb6" name="a50e9fbdd6a13e9e50cfba34656086bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e9fbdd6a13e9e50cfba34656086bb6">&#9670;&#160;</a></span>thisown</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thisown</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  property(<span class="keyword">lambda</span> x: x.this.own(), <span class="keyword">lambda</span> x, v: x.this.own(v),</div>
<div class="line">        doc=<span class="stringliteral">&#39;The membership flag&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ida__idp_8py.html">ida_idp.py</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceida__idp.html">ida_idp</a></li><li class="navelem"><a class="el" href="classida__idp_1_1_i_d_p___hooks.html">IDP_Hooks</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
