<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CSc 120: Pokemon data analysis</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link href="../../style.css" rel="stylesheet" type="text/css"/>

</head>
<body bgcolor="white">
<p>
<img src="../../IMGS/uadcs.gif" alt="University of Arizona, Department of Computer Science"/>
</p>

<h1>CSc 120: Pokemon data analysis</h1>

<h2>Introduction</h2>
This problem involves some simple data analysis and aims to give you some more
practice with combining Python data structures in interesting ways: in this case,
using two-level dictionaries (i.e., a dictionary of dictionaries).  The data, as it happens,
is about <a href="http://www.pokemon.com/us/" target="_blank">Pokemon</a>
(source: <a href="https://www.kaggle.com/abcsds/pokemon">www.kaggle.com</a>).
You are to write a program to read in Pokemon data from a file and organize it
according to Pokemon type (we will only consider <b>Type 1</b> for this
assignment), then repeatedly read in queries from the user and print out
solutions to those queries.
   
<h2>Restrictions</h2>
<ol>
  <li>
    For the long problems, your code should follow the <a href="../../pgm-style.html" target="_blank">style guidelines</a>
    for the class.
  <li>
You may not use concepts and/or short-hand syntax not yet covered in class. The restrictions include the following:

<ul>
  <li>
 dictionary or list comprehensions, e.g., [n * 2 for i in range(10)]
  </li>
  <li>
 with open (explicitly open and close the file instead)
  </li>
  <li>
 the ternary operator (use an if instead)
  </li>
  <li>
  nested functions (using def <i>within</i> a function to define another function)
  </li>
  <li>
 exceptions (try/except)
  </li>
  <li>
 type annotations
  </li>
  <li>
 lambda expressions 
  </li>
  <li>
 generators and user defined iterators
  </li>
  <li>
 default arguments
  </li>
  <li>
  decorators
  </li>
  <li>
 importing libraries (unless a library is explicitly mentioned in the specification)
  </li>
  </li>
</ol>
If you don't know what any of these are, don't worry, because you can't use them accidentally.

<h2>Input Format</h2>
The input file, <a href="Pokemon.csv" target="_blank">Pokemon.csv</a>, is in
<a href="https://en.wikipedia.org/wiki/Comma-separated_values" target="_blank">CSV format</a>
("comma-separated values").  This is a simple file format typically used
for tabular data such as that for spreadsheets, and if you want you can open this
file in a program like Excel or libreoffice to view the data in an easier-to-read
form.
<p/>
Any line in the input file that begins with the character '<tt>#</tt>' (without quotes)
is a <i>comment line</i> that should be ignored for data analysis.
<p/> 
The first line of the input file, which is a comment line, gives the meaning of
the various data columns (in this table, the number at the top of each entry
gives its position in a row of comma-separated values, e.g.,
&quot;Attack&quot; is at position 6):
<p/>
<blockquote>
  <table border="1" cellpadding="3">
    <tr>
      <td align="center" width="60">
	0<br/>
	No.
      </td>
      <td align="center" width="60">
	1<br/>
	Name
      </td>
      <td align="center" width="60">
	2<br/>
	Type 1
      </td>
      <td align="center" width="60">
	3<br/>
	Type 2
      </td>
      <td align="center" width="60">
	4<br/>
	Total strength
      </td>
      <td align="center" width="60">
	5<br/>
	HP
      </td>
      <td align="center" width="60">
	6<br/>
	Attack
      </td>
      <td align="center" width="60">
	7<br/>
	Defense
      </td>
      <td align="center" width="60">
	8<br/>
	Special Attack
      </td>
      <td align="center" width="60">
	9<br/>
	Special Defense
      </td>
      <td align="center" width="60">
	10<br/>
	Speed
      </td>
      <td align="center" width="60">
	11<br/>
	Generation
      </td>
      <td align="center" width="60">
	12<br/>
	Legendary?
      </td>
    </tr>
  </table>
</blockquote>

<h2>Expected Behavior</h2>

Write a program, in a file <b>pokemon.py</b>, that behaves as follows.
<p/>
<ol>
  <li>
    Read in the name of a data file. Use the <b><tt>input()</tt></b> function to prompt the user for the file name, but do not supply an argument to <b><tt>input()</tt></b>. (We call this a silent prompt.)
This file will be 
    a CSV file containing data about Pokemon in the format described
    above.  It can be the full <a href="Pokemon.csv">Pokemon.csv</a>
    data file, but you can also specify other input files that contain
    more or less information (e.g., a smaller file may be useful for
    testing or debugging).
  </li>
  <li>
    Read the data file specified above. <b>Do not use the Python csv module.</b>
    Organize the data into a data structure
    that collects together information about different Pokemon types.
    For this assignment, for the <b>Type</b>, we will consider only the <b>Type 1</b> field and ignore <b>Type 2</b> since this is not defined for all Pokemon.
  </li>
  <li>
    Repeatedly read and process queries from the user (see <b>Queries</b> below)
    until the user enters an empty line.
    Some examples are given <a href="EXAMPLES-pokemon.html" target="_blank">here</a>.
  </li>

</ol>

<h2>Queries</h2>
Your program will read in queries from the user, and for
each query, analyze the Pokemon data based on the query and print
out the results (see <b>Output Format</b> below).  
The queries and the corresponding analyses are as follows:
<p/>
<blockquote>
  <table border="1" cellpadding="8">
    <tr><th>User query</th> <th>Program action</th></tr>
    <tr>
      <td>
	<tt>Total</tt>
      </td>
      <td>
	Compute the Pokemon type(s) that have highest average <i>Total strength</i>.
      </td>
    </tr>
    <tr>
      <td>
	<tt>HP</tt>
      </td>
      <td>
	Compute the Pokemon type(s) that have highest average <i>HP</i>.
      </td>
    </tr>
    <tr>
      <td>
	<tt>Attack</tt>
      </td>
      <td>
	Compute the Pokemon type(s) that have highest average <i>Attack</i>.
      </td>
    </tr>
    <tr>
      <td>
	<tt>Defense</tt>
      </td>
      <td>
	Compute the Pokemon type(s) that have highest average <i>Defense</i>.
      </td>
    </tr>
    <tr>
      <td>
	<tt>SpecialAttack</tt>
      </td>
      <td>
	Compute the Pokemon type(s) that have highest average <i>Special Attack</i>.
      </td>
    </tr>
    <tr>
      <td>
	<tt>SpecialDefense</tt>
      </td>

      <td>
	Compute the Pokemon type(s) that have highest average <i>Special Defense</i>.
      </td>
    </tr>
    <tr>
      <td>
	 <tt>Speed</tt>
      </td>
      <td>
	Compute the Pokemon type(s) that have highest average <i>Speed</i>.
      </td>
    </tr>
    <tr>
      <td>&nbsp;<br/>
	<i>(empty line)</i></td>
      <td>Terminate query processing</td>
    </tr>
    <tr>
      <td>
	<i>anything else</i>
      </td>
      <td>Ignore the query</td>
    </tr>
  </table>
</blockquote>
<p/>
Note that, in each case, there may be more than one type of Pokemon with the
highest average value computed.  You should print out information about
each of them according to the output format given below.
<p/>
Matching the queries entered by the user's with the <b>User query</b> column 
shown above should be case-insensitive.  For example, the user inputs
<tt>Attack</tt>, 
<tt>attack</tt>, 
<tt>ATTACK</tt>, and
<tt>AtTaCk</tt>
should all be processed the same way.


<h2>Output Format</h2>
For each Pokemon type identified by your analysis, print out the result as follows:
<p/>
<blockquote>
  <b><tt>print("{}: {}".format(pokemon_type, max_average))</tt></b>
</blockquote>
<p/>
where <b><tt>pokemon_type</tt></b> is the type of Pokemon, and <b><tt>max_average</tt></b>
is the average value computed for that Pokemon type for that query (e.g., average total,
average HP, average Attack, etc.), which should be equal to the maximum
value for that query across all types. If more than one Pokemon type has the same maximum average for a property, then print each one out, one per line, in alphabetical order of the Pokemon type.

<h2>Programming Requirements</h2>
<ol>
  <li>
    Follow the <a href="../../pgm-style.html">style guidelines</a> for this class.
    <p/>
  </li>
  <li>
    Your code should not repeatedly and unnecessarily traverse all the
    data about all the Pokemon when processing queries.  To this end, organize your
    code and data as follows.
    <p/>
    <dl>
      <dt>
	<b>A. Data organization.</b>
      </dt>
      <dd>
	You are <b>required</b> to use a two-level dictionary (i.e., a dictionary of dictionaries) to implement your
        Pokemon database, as explained below:
        <ul>
          <li>
	    At the top level, information should be grouped by Pokemon type:
	    i.e., all of the information about Pokemon belonging to a particular
	    type should be grouped together.  A data structure that will do
	    this efficiently is the dictionary.
          </li>
          <li>
	    For each Pokemon type, we have to store information about all of the
	    different Pokemon that belong to that type.  Again, this can be done
	    efficiently using a dictionary that maps the Pokemon's name to its
	    properties (Total strength, Attack, Defense, etc.).
          </li>
        </ul>
	<p/>
	Additionally, for each Pokemon type you must pre-compute the average values for
	all of its properties (see <b>Code Organization</b> below).  These average values
	must also be organized as a dictionary keyed by Pokemon type.
      </dd>
      <dt>
	<b>B. Code organization.</b>
      </dt>
      <dd>
	Notice that the Pokemon properties you read in do not change during the computation.
	This means that the average value for any property for any given Pokemon type will
	remain the same as well.  This, in turn, means that the maximum average values will
	also not change.  Thus, these values can all be computed once and saved, with
	query processing simply looking up the saved values as needed.  This approach is
	closely related to an speedup technique called
	<a href="https://en.wikipedia.org/wiki/Memoization" target="_blank">memoization</a>.
	<p/>
	Your code should be organized as follows:
	<ul>
	  <li>
	    After reading in all the Pokemon data: for each Pokemon type, compute the average
	    value for each of its properties across all of the Pokemon that belong to that type.
	    Save this result into a dictionary indexed by Pokemon type.
	  </li>
	  <li>
	    Next, process the average values
	    obtained in the previous step to compute the maximum average value for each
	    property.  Optionally, at this point you can also compute which Pokemon types have the
	    maximum average value for each property.
	  </li>
	  <li>
	    Use these data to help process user queries until there are no queries to process.
	  </li>
	</ul>
      </dd>
    </dl>


  </li>
</ol >


<h2>Examples</h2>

Some examples of query processing, on different datasets, are shown
<a href="EXAMPLES-pokemon.html" target="_blank">Pokemon program input/output examples</a>.


<p/>
<hr/>

</body>
</html>

