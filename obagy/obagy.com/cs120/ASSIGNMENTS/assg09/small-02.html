<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CSc 120: Binary Search Trees</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link href="../../style.css" rel="stylesheet" type="text/css"/>

</head>
<body bgcolor="white">
<p>
<img src="../../IMGS/uadcs.gif" alt="University of Arizona, Department of Computer Science"/>
</p>

<h1>CSc 120: Binary Search Trees</h1>

<h2>Expected Behavior</h2>
Implement a class <b><tt>BinarySearchTree</tt></b> that behaves as specified below.
<p/>
Instances of this class should satisfy the <i>binary search tree property</i>. 
Namely, for every node in the tree, the values in the left subtree should all
be smaller than the value at that node; and the values in the right subtree 
should all be bigger than the value at that node.  To create a binary search
tree, begin with an empty tree and repeatedly insert values into it.
The algorithm for inserting a value into a binary search tree is given in
the lecture notes.

<h3>Attributes</h3>
Each node in the tree should have a value (an integer) as well as references 
to the left and right subtrees.  The names for the attributes are up to you.

<h3>Methods</h3>

Your class should implement (at least) the following methods:
<p/>
<blockquote>
<dl>
  <dt><b><tt>__init__(self)</tt></b></dt>
  <dd>
    Initializes a tree node to be empty.  Attribute values are set to
    <b><tt>None</tt></b>.
    <p/>
  </dd>
  
  <dt><b><tt>add(self, val)</tt></b></dt>
  <dd>
    Adds a node with the value <b><tt>val</tt></b> to the tree so
    as to maintain the binary search tree property (see above).
    <p/>
  </dd>

  <dt><b><tt>find(self, val)</tt></b></dt>
  <dd>
    Returns: a reference to the tree node with value <b><tt>val</tt></b>
    if it exists, <b><tt>None</tt></b> otherwise.
    <p/>
  </dd>

  <dt><b><tt>__str__(self)</tt></b></dt>
  <dd>
    Returns a string representation of the tree.  For the purposes of
    this assignment, this is defined as follows.  Given a tree <tt>T</tt>:
    <p/>
    <ul>
      <li>
	If <tt>T</tt> is <b><tt>None</tt></b> (i.e., empty), return the
	string &quot;<b><tt>None</tt></b>&quot;
	(the quotation marks simply indicate that the value is a string;
	they are not part of the string itself).
      </li>
      <li>
	Otherwise, suppose that <tt>T</tt> has a root node with value
	<i>val</i> and left and right subtrees <tt>T<sub>left</sub></tt> and 
	<tt>T<sub>right</sub></tt>.
	Return the string
	<blockquote>
	<tt><b>&quot;({:d} {} {})&quot;.format(</b>
		<i>val</i>, 
		str(T<sub>left</sub>),
		str(T<sub>right</sub>)<b>)</b></tt>
	</blockquote>

      </li>
    </ul>
    <p/>
  </dd>
</dl>
</blockquote>

<h2>Gotchas to watch out for</h2>
The code shown in the class lecture notes for binary search trees are
for <u>functions</u>, not methods for a class.  This problem asks you 
to write methods for a class.  The difference is that methods are invoked
on objects; in this case, these objects are binary search trees.
<p/>
This can become an issue when a recursive method reaches a node whose
left and/or right subtree is empty (i.e., <tt>None</tt>).  Attempting
to recurse on the empty subtree will generate an error because the
<tt>None</tt> object is not a tree and does not have the methods you
have written for this class.
<p/>
You can get around this problem by checking that you have a
non-<tt>None</tt> subtree before making a recursive call.  (The
case where the subtree is empty will, of course, have to be dealt
with appropriately.)

<h2>Examples</h2>
In each of the following examples, we construct a binary search tree by
inserting the sequence of values shown (in L-to-R order),then print out
the resulting tree.  
<p/>
<blockquote>
  <table border="1" cellpadding="10">
    <tr>
      <th>Input sequence (L-to-R)</th>
      <th>str(tree)</th>
    </tr>

    <tr>
      <td><tt>1 2 3</tt></td>
      <td><tt>(1 None (2 None (3 None None)))</tt></td>
    </tr>

    <tr>
      <td><tt>2 1 3</tt></td>
      <td><tt>(2 (1 None None) (3 None None))</tt></td>
    </tr>

    <tr>
      <td><tt> 5 3 1 2</tt></td>
      <td><tt>(5 (3 (1 None (2 None None)) None) None)</tt></td>
    </tr>

    <tr>
      <td><tt>4 3 2 1 5 6</tt></td>
      <td><tt>(4 (3 (2 (1 None None) None) None) (5 None (6 None None)))</tt></td>
    </tr>

    <tr>
      <td><tt>4 3 1 2 6 5</tt></td>
      <td><tt>(4 (3 (1 None (2 None None)) None) (6 (5 None None) None))</tt></td>
    </tr>
  </table>
</blockquote>
<p/>
In each of the following examples, we construct a binary search tree by
inserting the sequence of values shown (in L-to-R order),then print out
the tree returned by <b><tt>find(3)</tt></b>.
<p/>
<blockquote>
  <table border="1" cellpadding="10">
    <tr>
      <th>Input sequence (L-to-R)</th>
      <th>str(tree.find(3))</th>
    </tr>

    <tr>
      <td><tt>1 2 3</tt></td>
      <td><tt>(3 None None)</tt></td>
    </tr>

    <tr>
      <td><tt>2 1 3</tt></td>
      <td><tt>(3 None None)</tt></td>
    </tr>

    <tr>
      <td><tt> 5 3 1 2</tt></td>
      <td><tt>(3 (1 None (2 None None)) None)</tt></td>
    </tr>

    <tr>
      <td><tt>4 3 2 1 5 6</tt></td>
      <td><tt>(3 (2 (1 None None) None) None)</tt></td>
    </tr>

    <tr>
      <td><tt>4 3 1 2 6 5</tt></td>
      <td><tt>(3 (1 None (2 None None)) None)</tt></td>
    </tr>
  </table>
</blockquote>



</body>
</html>

