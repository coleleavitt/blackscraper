<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CSc 120: Sorting Linked Lists</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link href="../../style.css" rel="stylesheet" type="text/css"/>

</head>
<body bgcolor="white">
<p>
<img src="../../IMGS/uadcs.gif" alt="University of Arizona, Department of Computer Science"/>
</p>

<h1>CSc 120: Sorting Linked Lists</h1>

We will use an intuitively simple algorithm to sort linked lists.  The
essential idea is the following.  Given a linked list <b><tt>to_be_sorted</tt></b>
to sort, the algorithm repeatedly moves nodes
from the original list <b><tt>to_be_sorted</tt></b> to a new list
<b><tt>sorted</tt></b>, maintaining the invariant that
<b><tt>sorted</tt></b> is always kept in sorted order (i.e., for the
purposes of this assignment, in descending order by 
by the _value attribute in the short problem and the _count attribute in the long problem).
<p/>

<h2>Data structures</h2>

    The algorithm has a linked list,
    <b><tt>sorted</tt></b>, which contains all of the nodes
    that have been sorted so far.
    <p/>
    Initially, <b><tt>sorted</tt></b> is empty (i.e., 
    <b><tt>sorted._head</tt></b> has the value <tt>None</tt>).  Each iteration
    of the algorithm (step 2 below) adds a node to this linked list.  The
    algorithm maintains the invariant that this list is always kept in
    sorted order.
    <p/>

<h2>Algorithm</h2>

    The algorithm repeatedly performs the following steps:
    <p/>
    <ol>
      <li>
	Remove a node, call it <b><tt>curr_element</tt></b>, from the head of
	<b><tt>to_be_sorted</tt></b>.
	<p/>
      </li>
      <li>
	Iterate down the list <b><tt>sorted</tt></b> to find the position
	where <b><tt>curr_element</tt></b> should be inserted
	such that, after <b><tt>curr_element</tt></b> has been inserted,
	<b><tt>sorted</tt></b> remains in sorted order.
	<p/>
      </li>
      <li>
	Insert <b><tt>curr_element</tt></b> at that position in <b><tt>sorted</tt></b>.
	This results in one more element being placed in sorted order
	in the sorted list.
	<p/>
      </li>
    </ol>
    <p/>
    The iteration stops when all elements have been moved from 
    <b><tt>to_be_sorted</tt></b> to <b><tt>sorted</tt></b>.  At that point,
    <b><tt>to_be_sorted</tt></b> will have the value <tt>None</tt> and
    <b><tt>sorted</tt></b> will have all of the nodes in sorted order.
    The algorithm then
    copies the list <b><tt>sorted</tt></b> to the head of <b><tt>to_be_sorted</tt></b>.
    <p/>
The key step in the algorithm above is step 2.  The logic for this step is
as follows.  Here, we follow the requirement for this assignment
that the list should be sorted in descending order.  We say that an element
A is &quot;<i>smaller than</i>&quot; an element B if A's count is less than
B's count.
<p/>
<ol>
  <li type="a">
    If <b><tt>sorted</tt></b> is empty: add <b><tt>curr_element</tt></b> 
    to the head of <b><tt>sorted</tt></b>.
    <p/>
  </li>
  <li type="a">
    Otherwise, if the first element of <b><tt>sorted</tt></b> is smaller than
    <b><tt>curr_element</tt></b>: add <b><tt>curr_element</tt></b> at the
    head of <b><tt>sorted</tt></b> (so <b><tt>curr_element</tt></b> becomes the
    new first element).
    <p/>
  </li>
  <li type="a">
    Otherwise, iterate down <b><tt>sorted</tt></b> to find an element 
    <b><tt>E</tt></b> satisfying the following:
    <p/>
    <ol>
      <li type="i">
	<b><tt>E</tt></b> &ge; <b><tt>curr_element</tt></b>; 
	and
      </li>
      <li type="i">
	either <b><tt>E._next</tt></b> &lt; <b><tt>curr_element</tt></b>,
	or <b><tt>E._next</tt></b> is <tt>None</tt>.<p/>
	(The simplest way I can think of to do this uses two loops
	one after another:
	first, iterate down <b><tt>sorted</tt></b> to find the first node whose count
	is smaller than <b><tt>curr_element</tt></b>, call this node 
	<b><tt>E1</tt></b>; second, iterate down
	<b><tt>sorted</tt></b> again to find the node <b><tt>E</tt></b> just before
	<b><tt>E1</tt></b>.)
      </li>
    </ol>
    <p/>
    Insert <b><tt>curr_element</tt></b> immediately after <b><tt>E</tt></b>.
  </li>
</ol>
<p/>

<h2>Example</h2>

Suppose that, initially, the list <b><tt>to_be_sorted</tt></b> is the
following:
<p/>
<blockquote>
  <img src="IMGS/s0.png" width="30%" alt="s0.png"/>
</blockquote>
<p/>
<b>Iteration 1</b>
<p/>
<blockquote>
The first iteration of the algorithm moves the first element from
<b><tt>to_be_sorted</tt></b> for insertion into <b><tt>sorted</tt></b>:
<p/>
<blockquote>
  <img src="IMGS/s1.png" width="27%" alt="s1.png"/>
</blockquote>
<p/>
Since <b><tt>sorted</tt></b> is empty (Item <i>a</i> in the algorithm
above),  <b><tt>curr_element</tt></b> is added to it as its only element:
<p/>
<blockquote>
  <img src="IMGS/s2.png" width="27%" alt="s2.png"/>
</blockquote>
<p/>
Note that this preserves the invariant that <b><tt>sorted</tt></b> is
in sorted order.
</blockquote>
<p/>

<b>Iteration 2</b>
<p/>
<blockquote>
The algorithm again moves the (current) first element from
<b><tt>to_be_sorted</tt></b>:
<p/>
<blockquote>
  <img src="IMGS/s3.png" width="28%" alt="s3.png"/>
</blockquote>
<p/>
Since this element is bigger than the first element of <b><tt>sorted</tt></b>
(Item <i>b</i> in the algorithm above)
it is inserted at the head of <b><tt>sorted</tt></b>:
<p/>
<blockquote>
  <img src="IMGS/s4.png" width="23%" alt="s4.png"/>
</blockquote>
<p/>
Note that, again, this preserves the invariant that <b><tt>sorted</tt></b> is
in sorted order.
</blockquote>

<b>Iteration 3</b>
<p/>
<blockquote>
The algorithm once again moves the (current) first element from
<b><tt>to_be_sorted</tt></b>:
<p/>
<blockquote>
  <img src="IMGS/s5.png" width="33%" alt="s5.png"/>
</blockquote>
<p/>
Since this element is smaller than the first element of <b><tt>sorted</tt></b>
(Item <i>c</i> in the algorithm above),
the algorithm iterates down <b><tt>sorted</tt></b> to find the position
where it should be inserted.  In this case, item
<i>c</i>.ii of the algorithm applies, with <b><tt>E._next</tt></b> ==
<tt>None</tt>; i.e., <b><tt>curr_element</tt></b> is inserted at the end
of <b><tt>sorted</tt></b>:
<p/>
<blockquote>
  <img src="IMGS/s6.png" width="23%" alt="s6.png"/>
</blockquote>
<p/>
Note that, again, this preserves the invariant that <b><tt>sorted</tt></b> is
in sorted order.
</blockquote>
<p/>
This process is repeated with the remaining elements of the linked list
<b><tt>to_be_sorted</tt></b>.
<hr/>

</body>
</html>

