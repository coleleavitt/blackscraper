<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CSc 120: Decimal to Binary (Stacks)</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link href="../../style.css" rel="stylesheet" type="text/css"/>

</head>
<body bgcolor="white">
<p>
<img src="../../IMGS/uadcs.gif" alt="University of Arizona, Department of Computer Science"/>
</p>

<h1>CSc 120: Decimal to Binary (Stacks)</h1>

<h2>Expected Behavior</h2>
Write a function <b>decimal2binary</b>(<i>n</i>), that takes a non-zero integer 
<i>n</i> and returns a string representing <i>n</i> in base 2.
<p/>
<h2>Programming Requirements</h2>

Your solution must use the algorithm described below and must use a stack for auxillary storage.
<p/>
Solutions that do not use a stack will not get credit.

<h2>Algorithm</h2>
Converting between base 10 and base 2 is a common problem in computer science. In base 2, the 
digits of either 0 or 1 are multiplied by powers of 2. 
For example, the base 10 number 233 is 11101001 in base 2. 
The expression below shows the full computation:
<p>
1 x 2^7 + 1 x 2^6 + 1 x 2^5 + 0 x 2^4 + 1 x 2^3 + 0 x 2^2 + 0 x 2^1 + 1 x 2^0
</p>
A simple algorithm for finding the base 2 representation of a base 10 number is the following: repeatedly divide the decimal number by 2 and keep track of the remainder. The first division by 2 tells whether the number is even or odd. An even value will have a remainder of 0 and therefore a 0 in the ones place. The division process for converting 233 is shown below:
<p>
 233// 2 = 116 rem 1
<p>
       116 // 2 = 58  rem 0
<p>
              58 // 2 = 29 rem = 0
<p>
                     29 // 2 = 14 rem = 1
<p>
                           14 // 2 = 7  rem 0
<p>
                               7 // 2 = 3 rem = 1
<p>
                                    3 // 2 = 1 rem = 1
<p>
                                        1 // 2 = 0 rem = 1
</p>
<p>
Note that the first remainder computed is actually the last digit in the sequence. In other words, the digits are produced in the reverse order of their written sequence, which makes a stack perfectly suited to storing the remainders throughout this iterative process.

<p>
Use a stack as auxillary storage in your solution. The
<b><tt>Stack</tt></b> class is shown below for reference:
</p>
<blockquote>
<pre>
class Stack:
    def __init__(self):
        self._items = []

    def push(self, item):
        self._items.append(item)
    
    def pop(self):
        return self._items.pop()

    def is_empty(self):
        return self._items == []
    
    def __str__(self):
        return str(self._items) 
</pre>
</blockquote>

<h2>Examples</h2>
<ol>
  <li>
    <b><tt>decimal2binary(35)</tt></b><br/>
    return value: <b><tt>'100011'</tt></b>
    <p/>
  </li>
  <li>
    <b><tt>decimal2binary(255)</tt></b><br/>
    return value: <b><tt>'11111111'</tt></b>
    <p/>
  </li>
  <li>
    <b><tt>decimal2binary(19)</tt></b><br/>
    return value: <b><tt>'10011'</tt></b>
    <p/>
  </li>
  <li>
    <b><tt>decimal2binary(233)</tt></b><br/>
    return value: <b><tt>'11101001'</tt></b>
    <p/>
  </li>
</ol>

</body>
</html>

