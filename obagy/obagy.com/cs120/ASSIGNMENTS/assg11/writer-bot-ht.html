<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>CSc 120: Writer Bot with a Hash Table</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<link href="style.css" rel="stylesheet" type="text/css"/>

</head>
<body bgcolor="white">
<p>
<img src="../../IMGS/uadcs.gif" alt="University of Arizona, Department of Computer Science"/>
</p>

<h1>CSc 120: Writer Bot Hash Table</h1>


<h2>Background</h2>
<p>
This program is behaviorally identical to the Writer Bot program from 
<a href=../assg09/writer-bot.html target=_blank>Assignment 9</a>,
with these exceptions:
  <ol>
    <li>
        The program will be altered to use a hash table ADT rather than a Python built-in dictionary, as specified in <b>Programming Requirements</b>.
    <li>
        The input will include the table size for the hash table, as specified under <b>Input Format</b>.
    </li>
    <li>
        Some error checking is required as specified under <b>Errors</b>.
    </li>
  
  </ol>
</p>


<h2>Restrictions</h2>
<ol>
  <li>
    For the long problem, your code should follow the <a href="../../pgm-style.html" target="_blank">style guidelines</a>
    for the class. You must follow the updated guidelines for commenting classes.
  <li>
You may not use concepts and/or short-hand syntax not yet covered in class. The restrictions include the following:
<ul>
  <li>
 dictionary or list comprehensions, e.g., [n * 2 for i in range(10)]
  </li>
  <li>
 with open (explicitly open and close the file instead)
  </li>
  <li>
 the ternary operator (use an if instead)
  </li>
  <li>
  nested functions (using def <i>within</i> a function to define another function)
  </li>
  <li>
 exceptions (try/except)
  </li>
  <li>
 type annotations
  </li>
  <li>
 lambda expressions 
  </li>
  <li>
 generators and user defined iterators
  </li>
  <li>
 default arguments
  </li>
  <li>
  decorators
  </li>
  <li>
 importing libraries (unless a library is explicitly mentioned in the specification)
  </li>
  </li>
</ol>

<h2>Markov Chain Algorithm</h2>
<p>
As in 
<a href=../assg09/writer-bot.html target=_blank>Assignment 9</a>.
</p>

<h2>Definitions</h2>
As in 
<a href=../assg09/writer-bot.html target=_blank>Assignment 9</a>.
<h2>Expected Behavior</h2>
Write a program, in a file <b>writer_bot_ht.py</b>, that generates random text
from a given source text.  Your program should behave as follows:
<p/>
<ol>
  <li>
    Use <b><tt>input()</tt></b> (without arguments) to read the name of the
    the source file <i>sfile</i>.  Do <i><u>not</u></i>
    prompt the user for input.  Do <i><u>not</u></i> hard-code the file name
    into your program.
    <p/>
  </li>
  <li>
    Use <b><tt>input()</tt></b> (without arguments) to read the size of the
    the hash table <i>M</i>.  Do <i><u>not</u></i>
    prompt the user for input.  
    <p/>
  </li>
  <li>
    Use <b><tt>input()</tt></b> (without arguments) to read in the prefix size <i>n</i>.
    Do <i><u>not</u></i> prompt the user for input.
    <p/>
  </li>
  <li>
    Use <b><tt>input()</tt></b> (without arguments) to read in the number of words       to be generated for the random text.
    Do <i><u>not</u></i> prompt the user for input.
    <p/>
  </li>
  <li>
    Read <i>sfile</i> and build the Markov chain table of prefixes to suffixes 
    according to the description above.
    <p/>
  </li>
  <li>
    Construct the randomly generated text according to the Markov chain algorithm. Construct a list to hold the words of the generated text. 
    <p/>
  </li>
  <li>
    Print out the generated text list accoring to the <b>Output format</b> below.  
  </li>
</ol>
</p>

<h2>Input Format</h2>
<p>
As in 
<a href=../assg09/writer-bot.html target=_blank>Assignment 9</a> and repeated here.
</p>
Each line of the input file is a sequence of characters separated by whitespace.
The file may consists of any number of lines with any number of words on each line. 

<h2>Output Format</h2>

<p>
As in 
<a href=../assg09/writer-bot.html target=_blank>Assignment 9</a> and repeated here.
</p>

Print out the list of generated text <i>ten words per line</i>.
Any extra words will be printed on the last line. For example, if the generated text has only nine words, the output will consist of one line of nine words.
If the text has 109 words, the output will consist of eleven lines of output, the first ten lines having ten words and the last line having nine.

<h2>Programming Requirements</h2>

 <ol>
 <li>
  The example discussed above shows a table for prefixes of size two. <i>Your program must work for a prefix of arbitrary size n.</i>
 <p>
 </li>
 <li>
 Instead of using a Python dictionary to build the table mapping prefixes to suffixes, implement a hash table ADT.
 Previously, tuples were used to represent the prefixes. In this assignment, you will use strings to represent a prefix. For example, instead of using the tuple
<blockquote>
    <pre>
    ('Half, 'a')
    </pre>
</blockquote>
you will use the string 
 
<blockquote>
    <pre>
    'Half a'
    </pre>
</blockquote>
 Since the prefixes will be the keys in the hash table, you will use the hash function specified in the <b>Hash Function</b> section to hash a string representing a prefix to an integer. <i>You are required to use the given hash function.</i> Implement the following class, <code>Hashtable</code>:
<blockquote>
  <dl>
    <dt>
      <code>class Hashtable</code>
    </dt>
    <dd>
      An object of this class is a hash table that uses linear probing to handle collisions. It should 
      contain (at least) the following attributes:
      <ul>
	<li>
	  <b><tt>_pairs</tt></b>: the underlying Python list implementing the hash table.
	<li>
	  <b><tt>_size</tt></b>: the size of the hash table.
      </ul>
      <p>
      The class <i>must</i> implement (at least) the following methods:
      <ul>
	<li>
	  <b><tt>__init__(self, size)</tt></b>: initializes the object's
	  attributes as follows: <b><tt>_pairs</tt></b> is set to a list of size <b><tt>size</tt></b>;
	  <b><tt>_size</tt></b> is set to size.
	</li>
	<li>
	  <b><tt>put(self, key, value)</tt></b>: hashes <b><tt>key</b></tt> and inserts the <b><tt>key/value</b></tt> pair in the hash table.
           Use linear probing with a decrement of 1 to resolve collisions.
	</li>
	<li>
  <b><tt>get(self, key)</tt></b>: looks up <b><tt>key</b></tt> in the hash table and if found, returns the corresonding <b><tt>value</tt></b>. If not found, it returns <b><tt>None</tt></b>.
	</li>
	<li>
	  <b><tt>__contains__(self, key)</tt></b>: looks up <b><tt>key</b></tt> in the hash table and if found returns <b><tt>True</tt></b> and otherwise returns <b><tt>False</tt></b>.
	</li>
	<li>
	  <b><tt>__str__(self)</tt></b> returns a string representation of a <b><tt>Hashtable</b></tt> object.
	</li>
      </ul>
      <p/>
    </dd>
  </dl>
</blockquote>
<strong>Note:</strong> Do not use <b><tt>append()</b></tt> or list concatenation
  in the  <b><tt>put()</b></tt> method. (You will receive a deduction if you do!) 
The code that uses the hashtable ATD will modify a key's corresponding value when 
needed.
 <p>
 </li>
 <li>
As before, a prefix may have one or more suffixes. You must use 
a list to represent the possible suffixes. When a new suffix is encountered 
for an existing prefix, you must append the new suffix to the end of the list.
 This is important for matching the autograder output: the order in which suffixes 
are stored in the list will affect the choices made during text generation and will impact the output.
For example, suppose that <code>'Half a'</code> hashes to integer i and that <code>'a bee'</code> hashes to integer j.
The following shows the contents of the hash table at those indices for the Eric the Bee example:
<p/>
<blockquote>
<pre>
    hash table at index i is ['Half a', [ 'bee' ]]
    ...
    hash table at index j is ['a bee', [ 'philosophically', 'be', 'Due' ]]
</pre>
</blockquote> 
 </li>
 <li>
 In addition, during text generation, when a prefix has more than one suffix, the suffix will be randomly
 chosen from the list. You will use the Python random number generator as in Assignment 9 to do this.
As in that assigment, in order for your output to match the tester and grading scripts, you must seed the random 
number generator. To do this, define the following constant at the top of your program:
<blockquote>
<pre>
   SEED = 8
</pre>
<blockquote>
 </li>
 <li>
 You must define the constant <tt>NONWORD</tt>, which must be a word that cannot exist in the original text. In Assignment 9, a space was used for this, however, we need spaces to delineate the words of a prefix. Consequently,  define <tt>NONWORD</tt> as the single character <tt>@</tt> as follows:
<blockquote>
<pre>
   NONWORD = '@' 
</pre>
</blockquote>
 </li>
 <li>
 As you can imagine, when generating the output for larger text, it is not useful to print out the random text
one word at a time.  During the text generation phase, create a list to hold the words of the generated text.
When the text generation is complete, print the output as specified in the <b>Output format</b> section.
 </li>
 </ol> 

<p/>

<h2>Hash Function</h2>
<p/>
The hash function covered in lecture that hashes a string to an integer 
multiples the position of each character in the string by its ord value. 
That is straightforward but not robust enough for use in practice. 
A better approach is to compute a polynomial whose coefficients are the ord values of the individual characters in the string. Using 
<a href=http://mathworld.wolfram.com/HornersRule.html>Horner's rule</a> to 
compute the polynomial, and using 31 for the value of x, gives us the following 
hash function:
<blockquote>
  <pre>
    def _hash(self, key):
        p = 0
        for c in key:
            p = 31*p + ord(c)
        return p % self._size
  </pre>
</blockquote>


<h2>Errors</h2>
<p/>
The following are errors:
<p/>
<ol>
  <li>
    The input value <b><tt>n</tt></b> for the prefix size is less than one. 
    <p>
    <i>Program behavior:</i>  Use normal program logic to detect this (i.e., if statements). 
       Give the following error message:
    <p/>
    <i>Error message:</i>
    <tt><b>&quot;ERROR: specified prefix size is less than one&quot;</b></tt>
    <p/>
  <li>
    The input value for the size of the generated text is less than one.
    <p>
    <i>Program behavior:</i>  Use normal program logic to detect this (i.e., if statements). 
       Give the following error message:
<p/>
    <i>Error message:</i>
    <tt><b>&quot;ERROR: specified size of the generated text is less than one&quot; </b></tt>
    <p/>

    <p/>
  </li>
</ol>

<p>
Terminate the program after the 
errors above are reported. You may use Python's system library.
First, include the following import statement at the top of your program:
<blockquote>
<b><tt>import sys</tt></b>
</blockquote>
After printing the appropriate error message, exit your program like so:
<blockquote>
<b><tt>sys.exit(0)</tt></b>
</blockquote>

<h2>Examples</h2>
Some examples of generating random text from different source texts are shown 
<a href="examples-writer-bot.html" target="_blank">here</a>.
<p/>

<h2>Reference</h2>
The Markov chain algorithm is used to solve a variety of problems. Using it for random text generation has been described in many places, most notably in <i>The Practice of Programming</i>, by Kernighan and Pike,
which can be found
<a href="https://www.oreilly.com/library/view/the-practice-of/9780133133448/" target="_blank">here</a>.

<hr/>

</body>
</html>

