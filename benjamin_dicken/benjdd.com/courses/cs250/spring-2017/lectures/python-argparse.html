<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>cs250</title>
  <link href="https://fonts.googleapis.com/css?family=Lato:900|Work+Sans" rel="stylesheet">
  <link rel="stylesheet" href="/css/main.css">

  <link rel="stylesheet" href="/lib/highlight/styles/default.css">
  <script src="/lib/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <!-- Google fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&family=Poppins:ital,wght@0,400;0,700;1,400;1,700&family=Questrial&family=Roboto+Flex:opsz,wdth,wght,YTDE@8..144,110,400,-230;8..144,110,700,-230&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;1,100;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet">

  <style>
  .lnp {
    font-size: 1.5em;
  }
  </style>

</head>
<body style="background-color: rgb(255, 255, 255)">
<script src="/js/theme.min.js"></script>

  <h1 id="csc-250-lecture-notes-argparse">CSc 250: Lecture Notes: Argparse</h1>

<p><img src="/assets/memes/argparse.jpg" width="250" /></p>

<h2 id="introduction">Introduction</h2>

<p>We previously learned how to access command-line arguments using the <code class="language-plaintext highlighter-rouge">sys.argv</code> list.
Arguments that are expected to show up at an exact location on the command-line (a particular index of <code class="language-plaintext highlighter-rouge">sys.argv</code>) are know as <strong>positional</strong> arguments.
How an argument should be treated is determined by it’s exact position on the command line.
A <strong>non-positional</strong> argument is one that isn’t expected to show up at a specific position.
Rather, it is expected to show up after a particular identifier that begins with a dash (<code class="language-plaintext highlighter-rouge">-</code>).
Alternately, a <strong>non-positional</strong> argument can be the identifier itself.</p>

<p>Earlier in the semester, we used both positional and non-positional arguments.
For example, let’s look at a <code class="language-plaintext highlighter-rouge">cut</code> bash command that we’ve seen before:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cut -d " " -f 1 grades.txt
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">-d " "</code> is a non-positional argument.
<code class="language-plaintext highlighter-rouge">-d</code> is an identifier, which indicates that the cut delimiter is the argument following this one (<code class="language-plaintext highlighter-rouge">" "</code>).
<code class="language-plaintext highlighter-rouge">-f 1</code> is also a non-positional argument.
<code class="language-plaintext highlighter-rouge">-f</code> is an identifier, which indicates that the column number to cut is the argument following this one (<code class="language-plaintext highlighter-rouge">1</code>).
<code class="language-plaintext highlighter-rouge">grades.txt</code> is a positional argument. <code class="language-plaintext highlighter-rouge">cut</code> expects the <em>last</em> argument to be the file to cut from.</p>

<p>We can re-arrange the non-positional arguments, because the <code class="language-plaintext highlighter-rouge">cut</code> does not depend on their exact position in the argument list.
Both of the following work the same</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cut -d " " -f 1 grades.txt
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cut -f 1 -d " " grades.txt
</code></pre></div></div>

<p>But we cannot change the position of the positional argument.
Neither of the following work:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cut grades.txt -f 1 -d " "
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cut -f 1 grades.txt -d " "
</code></pre></div></div>

<p>It’s pretty clear to see how we can support positional arguments in python, given what we know about the <code class="language-plaintext highlighter-rouge">sys.argv</code> list.
But how can we support non-positional arguments?</p>

<p>One option is to write our own logic to handle this.
To accomplish this, we would have to search through <code class="language-plaintext highlighter-rouge">sys.argv</code> for the identifiers we are interested in, and then check the following argument to make sure it is what we expect.
Doing this manually is a pain in the butt, and there are a lot of edge cases we would need to worry about.</p>

<p>Fortunately, python has a built-in module for handling non-positional arguments called <code class="language-plaintext highlighter-rouge">argparse</code>.</p>

<h2 id="argparse">argparse</h2>

<p>The first step in using the <code class="language-plaintext highlighter-rouge">argparse</code> library is to <code class="language-plaintext highlighter-rouge">import</code> it, like we have done before with <code class="language-plaintext highlighter-rouge">sys</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import argparse
</code></pre></div></div>

<p>next, we must initialize an argument parser object by running:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parser = argparse.ArgumentParser()
</code></pre></div></div>

<p>Now <code class="language-plaintext highlighter-rouge">parser</code> is a variable which we can tell what kinds of arguments we expect to see on the command line.</p>

<p>To tell <code class="language-plaintext highlighter-rouge">parser</code> that we expect a particular argument, we can call the <code class="language-plaintext highlighter-rouge">add_argument</code> function.
For example, we can tell it that we want to handle <code class="language-plaintext highlighter-rouge">-x</code>, <code class="language-plaintext highlighter-rouge">-y</code>, and <code class="language-plaintext highlighter-rouge">-z</code> by doing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parser.add_argument('-x')
parser.add_argument('-y')
parser.add_argument('-z')
</code></pre></div></div>

<p>Once we’ve specified all of the arguments we want the program to handle, we must tell the parser to process the command-line arguments.
To do this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>args = parser.parse_args()
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">args</code> variable stores the processed arguments.
To access one f the processed arguments, you type <code class="language-plaintext highlighter-rouge">args</code> followed by a dot, followed by the name of the identifier.
To print out what the user inputted for <code class="language-plaintext highlighter-rouge">-x</code>, you should write:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print( args.x )
</code></pre></div></div>

<p>A complete (but very simple) example (named <code class="language-plaintext highlighter-rouge">ap-args.py</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import argparse

parser = argparse.ArgumentParser()

parser.add_argument('-x')
parser.add_argument('-y')
parser.add_argument('-z')

args = parser.parse_args()

print('-x is: ' + str(args.x))
print('-y is: ' + str(args.y))
print('-z is: ' + str(args.z))
</code></pre></div></div>

<p>If we run this and do not specify any arguments on the command line, we will get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 ap-args.py
-x is: None
-y is: None
-z is: None
</code></pre></div></div>

<p>If we run and specify arguments, but not the ones that <code class="language-plaintext highlighter-rouge">argparse</code> expects to see (the ones that we told it about), then it will generate and print a helpful warning message, and then exit the program.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 ap-args.py testing one two three
usage: ap-args.py [-h] [-x X] [-y Y] [-z Z]
ap-args.py: error: unrecognized arguments: testing one two three
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 ap-args.py -f FEE -g GEE
usage: ap-args.py [-h] [-x X] [-y Y] [-z Z]
ap-args.py: error: unrecognized arguments: -f FEE -g GEE
</code></pre></div></div>

<p>This is good, because <code class="language-plaintext highlighter-rouge">argparse</code> automatically makes sure that the user of the program is following the expected argument requirements.
But, if we specify only expected arguments, <code class="language-plaintext highlighter-rouge">argparse</code> will process them for us and allow us to access them as expected.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 ap-args.py -x Superman
-x is: Superman
-y is: None
-z is: None
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 ap-args.py -z Batman -x Superman
-x is: Superman
-y is: None
-z is: Batman
</code></pre></div></div>

<h2 id="help">Help!</h2>

<p><img src="/assets/memes/help-please.jpeg" width="250" /></p>

<p><code class="language-plaintext highlighter-rouge">argparse</code> has several nifty, built-in features.
One such feature is the functionality to automatically generate a help message.</p>

<p>Imagine a scenario where we have a python program, and we <em>know</em> it is supposed to take some command line arguments, but we don’t know which arguments it expects.
By default, <code class="language-plaintext highlighter-rouge">argparse</code> understands that <code class="language-plaintext highlighter-rouge">-h</code> means “print out a help message”.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 ap-args.py -h
usage: ap-args.py [-h] [-x X] [-y Y] [-z Z]

optional arguments:
  -h, --help  show this help message and exit
  -x X
  -y Y
  -z Z
</code></pre></div></div>

<p>This tells us everything <code class="language-plaintext highlighter-rouge">argparse</code> knows about the arguments it supports.
Notice that the information provided about <code class="language-plaintext highlighter-rouge">-x</code>, <code class="language-plaintext highlighter-rouge">-y</code> and <code class="language-plaintext highlighter-rouge">-z</code> is not all that useful.
It tells us that the program supports these, but it doesn’t tell us what these things represent!
Fortunately, <code class="language-plaintext highlighter-rouge">argparse</code> provides a way for the programmer to give extra information and specify extra requirements for each of these argument identifiers.
Before taking about this, we need to detour into <strong>named arguments</strong>.</p>

<h2 id="optional-and-named-arguments">Optional and Named Arguments</h2>

<p>(If you already know about optional and named arguments, feel free to skip this section)</p>

<p>We have already learned about how we can pass arguments to functions in python.</p>

<p>For example, take this simple function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def print_info(name, year, email):
    print('Person: ' + name)
    print('  * born: ' + str(year))
    print('  * email-address: ' + str(email))
</code></pre></div></div>

<p>If we import this function (in <code class="language-plaintext highlighter-rouge">functions.py</code>) into a python shell, we can call it like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info('Ben', 1920, 'bdd@gmail.com')
Person: Ben
  * born: 1920
  * email-address: bdd@gmail.com
</code></pre></div></div>

<p>As we know, we must specify all of the arguments, otherwise python will complain:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: print_info() missing 3 required positional arguments: 'name', 'year', and 'email'
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info('Ben', 1920)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  TypeError: print_info() missing 1 required positional argument: 'email'
</code></pre></div></div>

<p>We also need to give them to the function in the exact order that they were specified in the function definition.
Otherwise we will get output that we don’t want/expect.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info('Ben', 'bdd@gmail.com', 1920)
Person: Ben
  * born: bdd@gmail.com
  * email-address: 1920
</code></pre></div></div>

<p>Python actually gives us the flexibility to make some arguments optional.
In reality, the arguments are not truly optional, but we can give an argument a <em>default value</em> so that if we don’t specify the argument, python knows what it’s value is.
This is accomplished by assigning the argument to a default value in the function definition.
In the below example, we give each argument of <code class="language-plaintext highlighter-rouge">print_info</code> a default value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def print_info(name='John', year=2000, email='john@gmail.com'):
    print('Person: ' + name)
    print('  * born: ' + str(year))
    print('  * email-address:' + str(email))
</code></pre></div></div>

<p>Now, each of the arguments is optional.
If the function is called with no arguments, we will no longer get an error.
Instead, the function will run where each of the arguments are their default values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info()
Person: John
  * born: 2000
  * email-address:john@gmail.com
</code></pre></div></div>

<p>With default values, we can specify only <em>some</em> of the arguments, and it will still work:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info('Ben', 1920)
Person: Ben
  * born: 1920
  * email-address:john@gmail.com
</code></pre></div></div>

<p>The default value was only used for the argument that we did not give the function.</p>

<p>What do we do if we only want to specify the <em>email</em> argument?
Since it’s the last argument, just doing the following will not work, because ti interprets it as the <code class="language-plaintext highlighter-rouge">name</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info('bdd@gmail.com')
Person: bdd@gmail.com
  * born: 2000
  * email-address:john@gmail.com
</code></pre></div></div>

<p>This is where <em>named</em> arguments come into play.
Any argument that a function takes can be specified out-of-order by explicitly assigning it in the call to the function.
This happens like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info( email = 'bdd@gmail.com' )
Person: John
  * born: 2000
  * email-address:bdd@gmail.com
</code></pre></div></div>

<p>We were able to specify the last argument (<code class="language-plaintext highlighter-rouge">email</code>) by assigning it a value directly within the call to this function.
Named arguments allow us to pass values to a function in any order and combination that we want.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info( email='bdd@gmail.com', name='Benito', year=1777 )
Person: Benito
  * born: 1777
  * email-address:bdd@gmail.com
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; functions.print_info( email='bdd@gmail.com', year=2013 )
Person: John
  * born: 2013
  * email-address:bdd@gmail.com
</code></pre></div></div>

<h2 id="more-help">(More) Help!</h2>

<p>Now that we know (a little bit) about optional and named arguments, let’s get back to the <code class="language-plaintext highlighter-rouge">-h</code> conversation.
I mentioned before that we can give <code class="language-plaintext highlighter-rouge">argparse</code> more information about each argument identifier.
This is accompished by giving values to some arguments of <code class="language-plaintext highlighter-rouge">add_argument</code> that have default values.</p>

<p>One of the more useful named/optional arguments that can be specified is <code class="language-plaintext highlighter-rouge">help</code>, which should be assignment a string that describes the purpose of the argument.
Below is a modified version of the <code class="language-plaintext highlighter-rouge">ap-args.py</code> program from earlier named <code class="language-plaintext highlighter-rouge">personinfo.py</code>.
This prints out the same information that the <code class="language-plaintext highlighter-rouge">print_info</code> function did, but it takes the name, email, and year born as command-line arguments.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import argparse

parser = argparse.ArgumentParser()

parser.add_argument('-n', help='Your name')
parser.add_argument('-y', help='The year you were born in')
parser.add_argument('-e', help='Your email address')

args = parser.parse_args()

print('Person: ' + str(args.n))
print('  * born: ' + str(args.y))
print('  * email-address:' + str(args.e))
</code></pre></div></div>

<p>Notice that each call to the function <code class="language-plaintext highlighter-rouge">add_argument</code> now has a <code class="language-plaintext highlighter-rouge">help=...</code> specified.
<code class="language-plaintext highlighter-rouge">help</code> is an optional argument to <code class="language-plaintext highlighter-rouge">add_argument</code>.
We are not required to specify it, but if we do then the string will show up in the help message on the command-line when we call <code class="language-plaintext highlighter-rouge">-h</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 personinfo.py -h
usage: personinfo.py [-h] [-n N] [-y Y] [-e E]

optional arguments:
  -h, --help  show this help message and exit
  -n N        Your name
  -y Y        The year you were born in
  -e E        Your email address
</code></pre></div></div>

<p>Now it is clear what each argument is meant to be used for.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 personinfo.py -n Ben -e ben@email.com -y 2000
Person: Ben
  * born: 2000
  * email-address:ben@email.com
</code></pre></div></div>



<footer>
    <div>&nbsp</div>
    <div style="text-align:center;">	&copy; Benjamin Dicken 2016 - 2024 </div>
    <div>&nbsp</div>
</footer>

</body>
</html>
